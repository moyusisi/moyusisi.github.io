import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o,d as l}from"./app-CN8sbHCb.js";const c="/assets/servlet-DhHXt9CX.png",r={},s=l('<h2 id="servlet" tabindex="-1"><a class="header-anchor" href="#servlet"><span>Servlet</span></a></h2><ul><li><code>Servlet</code>是Sun公司提供的用于web开发的接口, 我们一般把实现了<code>Servlet</code>接口的程序称为<code>Servlet</code>程序</li><li><code>Servlet</code>应该由web服务器调用(比如通过配置<code>web.xml</code>), 自己不能独立运行</li><li><code>Servlet</code>接口有两个实现类<code>HttpServlet --&gt; GenericServlet</code>, <code>HttpServlet</code>重写了<code>service</code>方法, 根据请求方式自动调用<code>doGet</code>或<code>doPost</code>方法, 我们一般继承这个类, 重写<code>doGet、doPost</code>即可.</li></ul><h3 id="servlet生命周期" tabindex="-1"><a class="header-anchor" href="#servlet生命周期"><span>Servlet生命周期</span></a></h3><figure><img src="'+c+`" alt="Servlet生命周期" tabindex="0" loading="lazy"><figcaption>Servlet生命周期</figcaption></figure><p>如图:</p><ul><li>图中画出的是第一次请求<code>Servlet</code>的情况, 若对应的<code>Servlet</code>对象还没被创建, 则创建<code>Servlet</code>对象</li><li><code>Servlet</code>对象只初始化一次, 只会执行一次<code>init()</code>方法, <code>Servlet</code>初始化好之后, 新请求将直接到第5步</li><li>第2步中解析出的应用对应<code>getContextPath</code>, 资源对应<code>getServletPath</code></li><li>图中没画出<code>Servlet</code>的消亡, <code>Servlet</code>对象被创建后常驻内存, 继续为其他请求服务; web应用停止前调用<code>Servlet</code>的<code>destroy()</code>方法, <code>Servlet</code>生命周期才结束</li></ul><h3 id="servlet配置" tabindex="-1"><a class="header-anchor" href="#servlet配置"><span>Servlet配置</span></a></h3><ul><li>上面的<code>Servlet</code>是有第一个请求时被创建, 可以在<code>web.xml</code>中通过<code>&lt;load-on-startup&gt;</code>元素指定在web容器启动时就直接初始化<code>Servlet</code></li><li><code>Servlet</code>所映射的URL由<code>&lt;servlet-mapping&gt;</code>里的<code>&lt;url-pattern&gt;</code>指定, 它只有两个固定格式: <ol><li><code>*.扩展名</code>, 如: <code>*.do</code></li><li>以<code>/</code>开头(并以<code>/*</code>结尾), 如: <code>/abc</code>, <code>/abc/*</code></li></ol></li><li>URL映射以最精确的为准, 请求<code>/abc</code>时, 映射<code>/abc</code>和<code>/abc/*</code>都可以匹配, 但优先选择<code>/abc</code>; 请求<code>/a.do</code>时, <code>/*</code>和<code>*.do</code>都可以匹配, 但优先选择<code>/*</code>(即<code>/*</code>优先级高于<code>*.do</code>)</li></ul><h3 id="servletconfig" tabindex="-1"><a class="header-anchor" href="#servletconfig"><span>ServletConfig</span></a></h3><p>在<code>web.xml</code>中可以使用<code>&lt;init-param&gt;</code>标签为<code>Servlet</code>配置一些参数. <code>HttpServlet</code>类也实现了<code>ServletConfig</code>接口, 在创建<code>Servlet</code>对象时先把参数封装到<code>ServletConfig</code>对象中, 在调用<code>Servlet</code>的<code>init</code>方法时把<code>ServletConfig</code>对象传给<code>Servlet</code>.</p><p>在<code>Servlet</code>类中, 我们可以获取<code>ServletConfig</code>中的参数</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">ServletConfig config </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getServletConfig</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 这个方法继承自GenericServlet</span></span>
<span class="line"><span style="color:#E1E4E8;">String value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> config.</span><span style="color:#B392F0;">getInitParameter</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;charset&quot;</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">// 这可获取我们配置的参数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="servletcontext" tabindex="-1"><a class="header-anchor" href="#servletcontext"><span>ServletContext</span></a></h3><p><code>ServletContext</code>表示应用的上下文, 在Web容器在启动时, 会为每个Web应用程序都创建一个对应的<code>ServletContext</code>对象, 一个应用只有一个<code>ServletContext</code>对象, 被所有的<code>Servlet</code>共享.</p><p><code>ServletContext</code>的属性可以通过<code>web.xml</code>中的<code>&lt;context-param&gt;</code>标签来指定, 在程序中可以这样获取这些属性:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// ServletConfig 里维护了 ServletContext 对象的引用</span></span>
<span class="line"><span style="color:#E1E4E8;">ServletContext context </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getServletConfig</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getServletContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 因为 Servlet类实现了 ServletConfig 接口, 所以也可以直接获取</span></span>
<span class="line"><span style="color:#E1E4E8;">ServletContext context1 </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getServletContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 获取属性</span></span>
<span class="line"><span style="color:#E1E4E8;">context.</span><span style="color:#B392F0;">getAttribute</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;data&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 获取 &lt;display-name&gt; 标签配置的应用名</span></span>
<span class="line"><span style="color:#E1E4E8;">context.</span><span style="color:#B392F0;">getServletContextName</span><span style="color:#E1E4E8;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="filter" tabindex="-1"><a class="header-anchor" href="#filter"><span>Filter</span></a></h2><p><code>Servlet API</code>中提供了一个<code>Filter</code>接口, 称为过滤器, 所有的请求要先经过过滤器. web服务器在调用<code>Servlet</code>的<code>service()</code>方法之前会调用<code>Filter</code>的<code>doFilter()</code>方法.</p><p>web服务器把所有的<code>Filter</code>按注册顺序组成一个<code>filterChain</code>, 在调用<code>Filter</code>的<code>doFilter()</code>方法时, 会传递<code>filterChain</code>对象进来. <code>filterChain</code>也有个<code>doFilter</code>方法, 当调用<code>filterChain.doFilter()</code>时, web服务器会检查<code>filterChain</code>中是否还有<code>filter</code>, 如果有, 则调用下一个<code>filter</code>.</p><h3 id="filter生命周期" tabindex="-1"><a class="header-anchor" href="#filter生命周期"><span>Filter生命周期</span></a></h3><p><code>Filter</code>的创建和销毁由web服务器负责. web服务器启动时创建<code>Filter</code>实例对象, 并调用其<code>init</code>方法, 完成对象的初始化, 为用户请求作好拦截的准备. <code>Filter</code>对象只创建一次, <code>init</code>方法只执行一次. <code>Filter</code>也有初始化参数, 被封装到<code>FilterConfig</code>中, 它有个方法<code>getServletContext()</code>可获取<code>ServletContext</code></p><h3 id="装饰器模式-decorator" tabindex="-1"><a class="header-anchor" href="#装饰器模式-decorator"><span>装饰器模式(decorator)</span></a></h3><p>在<code>Servlet API</code>中体现了一种设计模式: 装饰器模式</p><p>装饰器模式的实现步骤:</p><ol><li>先看需要被增强对象实现了什么接口或继承了什么父类, 编写一个类也去继承这些接口或父类</li><li>内部定义一个变量, 类型为被包装类的类型, 并提供一个构造函数用于接收被包装对象</li><li>覆盖需要增强的方法, 添加增强内容</li><li>实现接口中其他方法, 调用被包装对象的对应方法.</li></ol><p><code>Servlet API</code> 提供了一个<code>HttpServletRequestWrapper</code>类, 该类就是采用装饰器模式对<code>HttpServletRequest</code>进行了增强(实际上在内部仅调用了一下所包装的对象的对应方法).</p><h2 id="listener" tabindex="-1"><a class="header-anchor" href="#listener"><span>Listener</span></a></h2><p>全称是事件监听器<code>EventListener</code>, 全类名是<code>java.util.EventListener</code>, <code>Servlet API</code>中的监听器也是继承这个接口.</p><p>监听器是典型的 <strong>观察者模式</strong> , 使用监听器要了解三个概念:</p><ul><li>事件源: 就是被监听的对象</li><li>事件对象: 就是被监听的对象发生的动作, 封装成了一个事件对象. 比如增加了一个属性</li><li>监听器: 对事件源发生的动作做出反应的对象. 由开发人员编写, 在事件监听器中, 可通过事件对象拿到事件源, 从而对事件源上的操作进行处理.</li></ul><h3 id="servlet监听器" tabindex="-1"><a class="header-anchor" href="#servlet监听器"><span>Servlet监听器</span></a></h3><p><code>Servlet</code>中的监听器不是直接注册在事件源上的, 而是由由WEB容器负责注册.</p><p>在<code>Servlet</code>规范中定义了多种类型的监听器, 它们用于监听的事件源分别为<code>ServletContext</code>, <code>HttpSession</code>和<code>ServletRequest</code>这三个对象.</p><p>根据监听的类型不同, 又可分为:</p><ul><li>监听事件源对象创建和销毁的事件监听器, 如: <code>ServletContextListener, HttpSessionListener, ServletRequestListener</code>.</li><li>监听事件源对象属性添加和删除的事件监听器, 如: <code>ServletContextAttributeListener, HttpSessionAttributeListener, ServletRequestAttributeListener</code>.</li><li>监听绑定到<code>HttpSession</code>中的对象的状态的事件监听器, 如: <code>HttpSessionBindingListener, HttpSessionActivationListener</code>, 这俩监听器比较特殊, 不需要在<code>web.xml</code>中进行注册</li></ul>`,35),n=[s];function d(a,i){return o(),t("div",null,n)}const S=e(r,[["render",d],["__file","2016-11-16-Servlet详解.html.vue"]]),h=JSON.parse('{"path":"/program/backend/2016-11-16-Servlet%E8%AF%A6%E8%A7%A3.html","title":"Servlet详解","lang":"zh-CN","frontmatter":{"title":"Servlet详解","date":"2016-11-16T00:00:00.000Z","category":"Java","tag":["Servlet"],"order":-20161116,"description":"Servlet Servlet是Sun公司提供的用于web开发的接口, 我们一般把实现了Servlet接口的程序称为Servlet程序 Servlet应该由web服务器调用(比如通过配置web.xml), 自己不能独立运行 Servlet接口有两个实现类HttpServlet --> GenericServlet, HttpServlet重写了serv...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/backend/2016-11-16-Servlet%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"Servlet详解"}],["meta",{"property":"og:description","content":"Servlet Servlet是Sun公司提供的用于web开发的接口, 我们一般把实现了Servlet接口的程序称为Servlet程序 Servlet应该由web服务器调用(比如通过配置web.xml), 自己不能独立运行 Servlet接口有两个实现类HttpServlet --> GenericServlet, HttpServlet重写了serv..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T16:41:59.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Servlet"}],["meta",{"property":"article:published_time","content":"2016-11-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-23T16:41:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Servlet详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-11-16T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-23T16:41:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"Servlet","slug":"servlet","link":"#servlet","children":[{"level":3,"title":"Servlet生命周期","slug":"servlet生命周期","link":"#servlet生命周期","children":[]},{"level":3,"title":"Servlet配置","slug":"servlet配置","link":"#servlet配置","children":[]},{"level":3,"title":"ServletConfig","slug":"servletconfig","link":"#servletconfig","children":[]},{"level":3,"title":"ServletContext","slug":"servletcontext","link":"#servletcontext","children":[]}]},{"level":2,"title":"Filter","slug":"filter","link":"#filter","children":[{"level":3,"title":"Filter生命周期","slug":"filter生命周期","link":"#filter生命周期","children":[]},{"level":3,"title":"装饰器模式(decorator)","slug":"装饰器模式-decorator","link":"#装饰器模式-decorator","children":[]}]},{"level":2,"title":"Listener","slug":"listener","link":"#listener","children":[{"level":3,"title":"Servlet监听器","slug":"servlet监听器","link":"#servlet监听器","children":[]}]}],"git":{"createdTime":1719160919000,"updatedTime":1719160919000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/backend/2016-11-16-Servlet详解.md","localizedDate":"2016年11月16日","excerpt":"","autoDesc":true}');export{S as comp,h as data};
