import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,d as a}from"./app-943XPxtz.js";const o={},r=a(`<h2 id="handlerinterceptor" tabindex="-1"><a class="header-anchor" href="#handlerinterceptor"><span>HandlerInterceptor</span></a></h2><p><code>Spring</code>提供的拦截器<code>Interceptor</code>与<code>Servlet</code>中的<code>Filter</code>不同的是, <code>Interceptor</code>采用<code>AOP</code>的方式在<code>Servlet</code>的<code>service</code>方法执行之前进行拦截, 可以进行更精细的控制.</p><p>在<code>Spring</code>中定义一个<code>Interceptor</code>只需要实现<code>HandlerInterceptor</code>接口, <code>Spring</code>已经为我们提供了一个<code>HandlerInterceptorAdapter</code>, 我们只需要继承它, 覆盖想要重写的方法.</p><h3 id="拦截器中的方法" tabindex="-1"><a class="header-anchor" href="#拦截器中的方法"><span>拦截器中的方法</span></a></h3><p><code>Interceptor</code>中有如下方法:</p><ul><li><code>preHandle</code>: 在<code>Controller</code>处理之前调用, 返回<code>false</code>时整个请求结束</li><li><code>postHandle</code>: 在<code>Controller</code>调用之后执行, 但它会在<code>DispatcherServlet</code>进行视图的渲染之前执行, 也就是说在这个方法中你可以对<code>ModelAndView</code>进行操作</li><li><code>afterCompletion</code>: 在整个请求完成之后执行, 也就是<code>DispatcherServlet</code>已经渲染了视图之后执行; 这个方法的主要作用是用于清理资源的</li><li><code>afterConcurrentHandlingStarted</code>: 这个方法是<code>AsyncHandlerInterceptor</code>接口中添加的. 当<code>Controller</code>中有异步请求方法的时候会触发该方法, 异步请求先支持<code>preHandle</code>、然后执行<code>afterConcurrentHandlingStarted</code>, 异步线程完成之后执行会再执行<code>preHandle、postHandle、afterCompletion</code></li></ul><p>关于最后那个方法, 举个列子:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">RestController</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> ExampleController</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">RequestMapping</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;/&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    DeferredResult&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">home</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        DeferredResult&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; dr </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#E1E4E8;"> DeferredResult&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        dr.</span><span style="color:#B392F0;">setResult</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;成功&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> dr;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这样的<code>Controller</code>里面有个异步结果, 则拦截器的执行顺序将是: <code>preHandle -&gt; afterConcurrentHandlingStarted -&gt; preHandle -&gt; postHandle -&gt; afterCompletion</code>.</p><p>如果把<code>dr.setResult(&quot;成功&quot;);</code> 这句删掉, 将只执行<code>preHandle -&gt; afterConcurrentHandlingStarted</code></p><p>可以认为, <code>afterConcurrentHandlingStarted</code>是返回异步结果时调用(此时异步结果里不需要有数据), 而<code>postHandle</code>必须是返回的结果执行完, 异步结果中有数据了(<code>dr.setResult</code>)才调用.</p><h2 id="spring-boot-定制-interceptor" tabindex="-1"><a class="header-anchor" href="#spring-boot-定制-interceptor"><span>Spring boot 定制 Interceptor</span></a></h2><p>首先我们先定义我们自己的拦截器, 方式还是继承<code>HandlerInterceptorAdapter</code>, 覆盖想要的方法:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Component</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> MyInterceptor</span><span style="color:#F97583;"> extends</span><span style="color:#B392F0;"> HandlerInterceptorAdapter</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> boolean</span><span style="color:#B392F0;"> preHandle</span><span style="color:#E1E4E8;">(HttpServletRequest </span><span style="color:#FFAB70;">request</span><span style="color:#E1E4E8;">, HttpServletResponse </span><span style="color:#FFAB70;">response</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">handler</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>像这样我们把<code>MyInterceptor</code>作为一个<code>Bean</code>, <code>Spring boot</code>并不会帮我们注册到拦截器列表中. 就像添加消息转换器一样, 我们可以在继承<code>WebMvcConfigurerAdapter</code>的配置类里, 通过覆盖方法来添加:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Configuration</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> WebMvcConfig</span><span style="color:#F97583;"> extends</span><span style="color:#B392F0;"> WebMvcConfigurerAdapter</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">      // 拦截器需要手动加入到调用链中</span></span>
<span class="line"><span style="color:#E1E4E8;">      @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">      public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> addInterceptors</span><span style="color:#E1E4E8;">(InterceptorRegistry </span><span style="color:#FFAB70;">registry</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          registry.</span><span style="color:#B392F0;">addInterceptor</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> MyInterceptor</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16),t=[r];function l(p,c){return n(),s("div",null,t)}const E=e(o,[["render",l],["__file","2016-11-18-SpringBoot与HandlerInterceptor.html.vue"]]),y=JSON.parse('{"path":"/program/spring/2016-11-18-SpringBoot%E4%B8%8EHandlerInterceptor.html","title":"SpringBoot与HandlerInterceptor","lang":"zh-CN","frontmatter":{"title":"SpringBoot与HandlerInterceptor","date":"2016-11-18T00:00:00.000Z","category":"Spring","tag":["Spring"],"order":-20161118,"description":"HandlerInterceptor Spring提供的拦截器Interceptor与Servlet中的Filter不同的是, Interceptor采用AOP的方式在Servlet的service方法执行之前进行拦截, 可以进行更精细的控制. 在Spring中定义一个Interceptor只需要实现HandlerInterceptor接口, Spri...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/spring/2016-11-18-SpringBoot%E4%B8%8EHandlerInterceptor.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"SpringBoot与HandlerInterceptor"}],["meta",{"property":"og:description","content":"HandlerInterceptor Spring提供的拦截器Interceptor与Servlet中的Filter不同的是, Interceptor采用AOP的方式在Servlet的service方法执行之前进行拦截, 可以进行更精细的控制. 在Spring中定义一个Interceptor只需要实现HandlerInterceptor接口, Spri..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-09T09:40:25.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Spring"}],["meta",{"property":"article:published_time","content":"2016-11-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-09T09:40:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SpringBoot与HandlerInterceptor\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-11-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-09T09:40:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"HandlerInterceptor","slug":"handlerinterceptor","link":"#handlerinterceptor","children":[{"level":3,"title":"拦截器中的方法","slug":"拦截器中的方法","link":"#拦截器中的方法","children":[]}]},{"level":2,"title":"Spring boot 定制 Interceptor","slug":"spring-boot-定制-interceptor","link":"#spring-boot-定制-interceptor","children":[]}],"git":{"createdTime":1719160919000,"updatedTime":1725874825000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/spring/2016-11-18-SpringBoot与HandlerInterceptor.md","localizedDate":"2016年11月18日","excerpt":"","autoDesc":true}');export{E as comp,y as data};
