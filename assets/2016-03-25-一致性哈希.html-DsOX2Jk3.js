import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c,d as t}from"./app-J8acWEVP.js";const o="/assets/hash01-BDDtPLP8.png",h="/assets/hash02-BTxHfD0I.png",i="/assets/hash03-DPXN-tDV.png",n="/assets/hash04-BbkjVVgu.png",s="/assets/hash05-DlKbxYYb.png",r={},l=t('<p>一致性哈希在哈希算法基础上, 适用于动态变化的Cache环境中</p><h2 id="场景" tabindex="-1"><a class="header-anchor" href="#场景"><span>场景</span></a></h2><p>如果我们有4台Cache服务器来存放一些对象, 可以用简单的办法来分配:<code>object.hashCode() % 4</code>.</p><ul><li>Cache0: <code>object.hashCode() % 4 == 0</code></li><li>Cache1: <code>object.hashCode() % 4 == 1</code></li><li>Cache2: <code>object.hashCode() % 4 == 2</code></li><li>Cache3: <code>object.hashCode() % 4 == 3</code></li></ul><p>动态变化体现在, 如果因为某些原因Cache服务器少了一台或者多了一台, 我们怎么处理对象与服务器的关系呢?<br> 少了一台应该<code>%3</code>, 多了一台应该<code>%5</code>, 这样服务器上原来存放的对象与服务器的对应关系就全乱了</p><h2 id="使用一致性哈希解决上述场景" tabindex="-1"><a class="header-anchor" href="#使用一致性哈希解决上述场景"><span>使用一致性哈希解决上述场景</span></a></h2><h3 id="算法步骤" tabindex="-1"><a class="header-anchor" href="#算法步骤"><span>算法步骤</span></a></h3><p>一致性哈希算法采用一种新的方式来解决问题，不再仅仅依赖object.hashCode()本身，而且将Cache的配置也进行哈希运算。具体步骤如下:</p><ol><li>先求出每个Cache的哈希值, 并将其配置到一个0~2^32的圆环区间上(为啥是32?哈希值一般不超过32位)</li><li>求出需要存储对象的哈希值, 也将其配置到这个圆环上</li><li>从对象所映射到的位置顺时针开始找, 把对象保存在第一个找到的Cache节点上</li></ol><figure><img src="'+o+'" alt="一致性哈希算法" tabindex="0" loading="lazy"><figcaption>一致性哈希算法</figcaption></figure><h3 id="新增cache服务器的情景" tabindex="-1"><a class="header-anchor" href="#新增cache服务器的情景"><span>新增Cache服务器的情景</span></a></h3><p>假设在这个环形哈希空间中, Cache5被映射在Cache3和Cache4之间, 那么受影响的将仅是沿Cache5逆时针遍历, 直到下一个Cache(Cache3)之间的对象. 只对这些对象进行转移即可. Cache3~Cache5之间部分原来映射到Cache4, 现在应该映射到Cache5;<br> Cache5~Cache4之间部分原来映射到Cache4, 现在还是映射到Cache4, 不受影响;</p><figure><img src="'+h+'" alt="新增Cache服务器的情景" tabindex="0" loading="lazy"><figcaption>新增Cache服务器的情景</figcaption></figure><h3 id="删除cache服务器的情景" tabindex="-1"><a class="header-anchor" href="#删除cache服务器的情景"><span>删除Cache服务器的情景</span></a></h3><p>假设在这个环形哈希空间中, Cache3被移除, 那么受影响的将仅是沿Cache3逆时针遍历直到下一个Cache(Cache2)之间的对象</p><p>原来Cache2~Cache3之间部分原来映射到Cache3, 现在应该映射到Cache4;<br> 原来Cache3~Cache4之间部分原来映射到Cache4, 现在还是映射到Cache4, 不受影响;</p><figure><img src="'+i+'" alt="删除Cache服务器的情景" tabindex="0" loading="lazy"><figcaption>删除Cache服务器的情景</figcaption></figure><h2 id="虚拟cache服务器" tabindex="-1"><a class="header-anchor" href="#虚拟cache服务器"><span>虚拟Cache服务器</span></a></h2><p>考虑到哈希算法并不是保证绝对的平衡, 尤其Cache较少的话, 对象并不能被均匀的映射到Cache上. 为了解决这种情况引入了&quot;虚拟节点&quot;的概念.<br> 虚拟节点是实际节点在环形空间的复制品, 一个实际节点对应了若干个&quot;虚拟节点&quot;, 这个对应个数也称为&quot;复制个数&quot;, &quot;虚拟节点&quot;在哈希空间中以哈希值排列.</p><p>仍以4台Cache服务器为例,设置&quot;复制个数&quot;为2后, 共有8个“虚拟节点”分部在环形区域上, 会如下图一样:</p><figure><img src="'+n+'" alt="虚拟节点" tabindex="0" loading="lazy"><figcaption>虚拟节点</figcaption></figure><p>引入了&quot;虚拟节点&quot;后，映射关系就从<code>对象--&gt;Cache服务器</code>转换成了<code>对象--&gt;虚拟节点--&gt;Cache服务器</code>. 当然虚拟节点与真正的服务器之间也有对应关系. 查询对象所在Cache服务器的映射关系整个流程如下图所示:</p><figure><img src="'+s+'" alt="映射关系" tabindex="0" loading="lazy"><figcaption>映射关系</figcaption></figure>',23),p=[l];function d(C,g){return a(),c("div",null,p)}const f=e(r,[["render",d],["__file","2016-03-25-一致性哈希.html.vue"]]),_=JSON.parse('{"path":"/program/linux/2016-03-25-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.html","title":"一致性哈希","lang":"zh-CN","frontmatter":{"title":"一致性哈希","date":"2016-03-25T00:00:00.000Z","category":"Java","tag":["一致性哈希"],"order":-20160325,"description":"一致性哈希在哈希算法基础上, 适用于动态变化的Cache环境中 场景 如果我们有4台Cache服务器来存放一些对象, 可以用简单的办法来分配:object.hashCode() % 4. Cache0: object.hashCode() % 4 == 0 Cache1: object.hashCode() % 4 == 1 Cache2: objec...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/linux/2016-03-25-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"一致性哈希"}],["meta",{"property":"og:description","content":"一致性哈希在哈希算法基础上, 适用于动态变化的Cache环境中 场景 如果我们有4台Cache服务器来存放一些对象, 可以用简单的办法来分配:object.hashCode() % 4. Cache0: object.hashCode() % 4 == 0 Cache1: object.hashCode() % 4 == 1 Cache2: objec..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-09T08:17:39.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"一致性哈希"}],["meta",{"property":"article:published_time","content":"2016-03-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-09T08:17:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"一致性哈希\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-03-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-09T08:17:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"场景","slug":"场景","link":"#场景","children":[]},{"level":2,"title":"使用一致性哈希解决上述场景","slug":"使用一致性哈希解决上述场景","link":"#使用一致性哈希解决上述场景","children":[{"level":3,"title":"算法步骤","slug":"算法步骤","link":"#算法步骤","children":[]},{"level":3,"title":"新增Cache服务器的情景","slug":"新增cache服务器的情景","link":"#新增cache服务器的情景","children":[]},{"level":3,"title":"删除Cache服务器的情景","slug":"删除cache服务器的情景","link":"#删除cache服务器的情景","children":[]}]},{"level":2,"title":"虚拟Cache服务器","slug":"虚拟cache服务器","link":"#虚拟cache服务器","children":[]}],"git":{"createdTime":1719158757000,"updatedTime":1725869859000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/linux/2016-03-25-一致性哈希.md","localizedDate":"2016年3月25日","excerpt":"","autoDesc":true}');export{f as comp,_ as data};
