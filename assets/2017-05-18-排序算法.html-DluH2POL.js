import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as a,d as l}from"./app-DQ46ret3.js";const p="/assets/maxHeap-DsGxNh4K.png",e={},o=l(`<p>常见排序算法的分类</p><h3 id="插入类排序" tabindex="-1"><a class="header-anchor" href="#插入类排序"><span>插入类排序</span></a></h3><p>基本思想：每次将一个元素插入到前面已经排好序的子序列中</p><p>主要包括：<code>直接插入排序</code>、<code>折半插入排序</code></p><h3 id="交换类排序" tabindex="-1"><a class="header-anchor" href="#交换类排序"><span>交换类排序</span></a></h3><p>基本思想：根据两个元素的比较结果来交换两个元素在序列中的位置。</p><p>主要包括：<code>冒泡排序</code>、<code>快速排序</code></p><h3 id="选择类排序" tabindex="-1"><a class="header-anchor" href="#选择类排序"><span>选择类排序</span></a></h3><p>基本思想：每趟都从待排序列中选取一个最小值作为序列的第i个元素,直到第n-1趟，待排序列只剩下一个元素。</p><p>主要包括：<code>简单选择排序</code>、<code>堆排序</code>(借助<code>完全二叉树</code>的概念)、<code>归并排序</code></p><h2 id="直接插入排序" tabindex="-1"><a class="header-anchor" href="#直接插入排序"><span>直接插入排序</span></a></h2><p>基本思想：一个数组, 左边有序(起始只有一个元素), 把右边元素依次插入到左边的有序表</p><p>算法描述：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// 直接插入排序</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> insertSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] array, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> i, j;</span></span>
<span class="line"><span style="color:#6A737D;">    // [1, n-1]依次插入到前面的有序表</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 临时存放待插入元素</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[i];</span></span>
<span class="line"><span style="color:#6A737D;">        // 若tmp小于前序, 需将前序后移并寻找插入位置</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (tmp </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> array[i </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line"><span style="color:#6A737D;">            // 向前逐个比较，大于tmp的元素都要后移，寻找插入位置</span></span>
<span class="line highlighted"><span style="color:#F97583;">            for</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&gt;=</span><span style="color:#79B8FF;"> 0</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#E1E4E8;"> tmp </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> array[j]; j</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">                array[j </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[j];</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#6A737D;">            // 找到插入位置(array[j]后面)</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">            array[j </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>空间复杂度: <code>O(1)</code>, 借助于了一个临时存放单元</li><li>时间复杂度: <code>O(n^2)</code>, 最好情况下, 元素已经有序, 时间复杂度为<code>O(n)</code></li><li>稳定性: 稳定</li><li>适用场景: 基本有序</li></ul><h2 id="折半插入排序" tabindex="-1"><a class="header-anchor" href="#折半插入排序"><span>折半插入排序</span></a></h2><p>基本思想：也是左边有序, 右边依次插入有序表, 不同的是找插入位置时, 使用折半查找法</p><p>算法描述：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// 折半插入排序</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> binaryInsertSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] array, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> i, j;</span></span>
<span class="line"><span style="color:#6A737D;">    // [1, n-1]依次插入到前面的有序表</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 临时存放待插入元素</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[i];</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">, right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">        // 折半法寻找tmp的插入位置</span></span>
<span class="line highlighted"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line highlighted"><span style="color:#F97583;">            int</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> right) </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line highlighted"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (tmp </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> array[mid]) {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">                right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">                left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">            }</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#6A737D;">        // 移动元素 出循环后有 left &gt; right 且 left = right + 1</span></span>
<span class="line highlighted"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> left; j</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">            array[j </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[j];</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        array[left] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>空间复杂度: <code>O(1)</code></li><li>时间复杂度: <code>O(n^2)</code>, 仅减少了比较次数, 大约为<code>O(nlogn)</code>(log表示以2为底的对数), 且比较次数与初始顺序无关</li><li>稳定性: 稳定</li><li>适用场景: 数据量不大</li></ul><h2 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序"><span>冒泡排序</span></a></h2><p>基本思想：从后向前(也可从前向后)依次比较相邻两元素，若为逆序则交换，这样一趟冒泡会把最小的元素交换到第一个位置; 下一趟冒泡时, 第一个元素就不再参与了，这样每次都把最小元素交换到前面，总共进行<code>n-1</code>趟冒泡就可以了。</p><p>算法描述：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// 冒泡排序</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> bubbleSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] array, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 外层循环控制排序的趟数(n-1 趟)</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 内层循环用于比较和交换，即一趟冒泡</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> i; j</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">            // 相邻元素比较</span></span>
<span class="line highlighted"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (array[j] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> array[j </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line highlighted"><span style="color:#6A737D;">                // 交换相邻元素</span></span>
<span class="line highlighted"><span style="color:#F97583;">                int</span><span style="color:#E1E4E8;"> tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[j];</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">                array[j] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[j </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">                array[j </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp;</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>空间复杂度：<code>O(1)</code></li><li>时间复杂度：<code>O(n^2)</code>，最好情况下，元素已经有序，时间复杂度为<code>O(n)</code></li><li>稳定性：稳定</li><li>适用场景：基本有序</li></ul><p>关于交换元素的方法还可以有如下写法:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#B392F0;">example</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 借助临时单元</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">    a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">    b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp;</span></span>
<span class="line"><span style="color:#6A737D;">    // 加减操作交换 注意有可能溢出</span></span>
<span class="line"><span style="color:#E1E4E8;">    a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">    b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">    a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#6A737D;">    // 位操作交换</span></span>
<span class="line"><span style="color:#E1E4E8;">    a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">^</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">    b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">^</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">    a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">^</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序"><span>快速排序</span></a></h2><p>基本思想：基于分治法，在n个元素中任取一个元素<code>pivot</code>(一般为第一个元素)作为基准， 一趟排序后把数据分成两部分， 左边<code>L[0 ~ k-1]</code>和右边<code>L[k+1 ~ n-1]</code>，使得左边元素都小于<code>pivot</code>, 右边都大于<code>pivot</code>, 而<code>pivot</code>直接复制到<code>L[k]</code>上, 这个过程成为一趟快排;<br> 然后对左子表和右子表分别进行上述过程, 直到每部分只有一个元素或为空为止, 即所有元素都放在了最终位置上。</p><p>算法描述：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// 快速排序</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> quickSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] array, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 划分函数, 找到基准应该在的位置</span></span>
<span class="line highlighted"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> pos </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> partition</span><span style="color:#E1E4E8;">(array, left, right);</span></span>
<span class="line"><span style="color:#6A737D;">        // 左边排序</span></span>
<span class="line"><span style="color:#B392F0;">        quickSort</span><span style="color:#E1E4E8;">(array, left, pos </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">        // 右边排序</span></span>
<span class="line"><span style="color:#B392F0;">        quickSort</span><span style="color:#E1E4E8;">(array, pos </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, right);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 划分函数，一趟排序的过程。返回值为基准下标</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#B392F0;"> partition</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] array, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 以第一个元素作为基准</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> pivot </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[left];</span></span>
<span class="line"><span style="color:#F97583;">    while</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 从后向前找到第一个小于pivot的元素</span></span>
<span class="line highlighted"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> pivot </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> array[right]) right</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">        // 把小于pivot的元素换到左边</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">        array[left] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[right];</span></span>
<span class="line"><span style="color:#6A737D;">        // 从前向后找到第一个大于pivot的元素</span></span>
<span class="line highlighted"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> pivot </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> array[left]) left</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">        // 把大于pivot的元素换到右边</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">        array[right] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[left];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 出循环时总会有 left == right，把 pivot 放到这里</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">    array[left] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pivot;</span></span>
<span class="line"><span style="color:#6A737D;">    // 返回基准在的位置</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> left;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>空间复杂度: <code>O(n)</code>, 栈深度最好为<code>log(n+1)</code>, 最坏为<code>n-1</code>, 平均栈深度<code>O(logn)</code></li><li>时间复杂度: 最好<code>O(nlogn)</code>, 最坏(有序时最坏)<code>O(n^2)</code>, 平均接近最好情况;</li><li>稳定性: 不稳定</li><li>适用场景：快排是是所有排序算法中<code>平均性能最优的</code></li></ul><h2 id="简单选择排序" tabindex="-1"><a class="header-anchor" href="#简单选择排序"><span>简单选择排序</span></a></h2><p>基本思想: 第<code>i</code>趟从<code>L[i ~ n]</code>中选择关键字最小的元素与<code>L[i]</code>交换, 这样每趟都可确定一个元素的最终位置, 经过<code>n-1</code> 趟就可以使整个序列有序。</p><p>算法描述:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// 简单选择排序</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> selectSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] array, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 外层循环控制排序的趟数(n-1 趟)</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 记录最小元素位置</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> min </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#6A737D;">        // 从[i, n-1]中选出最小的</span></span>
<span class="line highlighted"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> i; j</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line highlighted"><span style="color:#6A737D;">            // 更新最小元素位置</span></span>
<span class="line highlighted"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (array[min] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> array[j]) {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">                min </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j;</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">            }</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#6A737D;">        // 最小元素交换到i位置</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">        array[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array[min];</span></span>
<span class="line"><span style="color:#E1E4E8;">        array[min] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>空间复杂度: <code>O(1)</code></li><li>时间复杂度: <code>O(n^2)</code></li><li>稳定性: 不稳定</li></ul><h2 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序"><span>堆排序</span></a></h2><h2 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序"><span>归并排序</span></a></h2><h3 id="堆排序-1" tabindex="-1"><a class="header-anchor" href="#堆排序-1"><span>堆排序</span></a></h3><ul><li>特点: 在排序过程中, 把<code>L[1 ~ n]</code>看成是一颗<code>完全二叉树</code>的顺序存储结构, 利用完全二叉树中父节点和子节点的内在关系, 在当前无需区中选择关键字最大(或最小)的元素</li><li>完全二叉树: 若二叉树除最后一层外, 其它各层的结点数都达到最大个数, 最后一层所有的结点都连续集中在最左边, 这就是完全二叉树</li><li>小根堆: <code>L[1~n]</code>满足 <code>L[i]&lt;=L[2i]</code>且<code>L[i]&lt;=L[2i+1]</code></li><li>大根堆: <code>L[1~n]</code>满足 <code>L[i]&gt;=L[2i]</code>且<code>L[i]&gt;=L[2i+1]</code></li><li>大根堆示例:(左右兄弟结点没有大小关系)</li></ul><figure><img src="`+p+`" alt="maxHeap" tabindex="0" loading="lazy"><figcaption>maxHeap</figcaption></figure><ul><li><p>算法思想: 堆排序主要包括两个步骤</p><ol><li>创建初始堆: 堆排序的关键就是构造初始堆. <code>n</code>个结点的完全二叉树, 最后一个结点一定是<code>n/2</code>个结点的子结点, 所以我们从<code>n/2</code>结点开始保证它是一个堆, 然后不断向前调整, 保证每个结点都大于左右子结点(不大于则交换). 当然在过程中可能因为交换破坏了下一级的堆, 这时要继续调整下一级堆, 保证子树构造成堆为止. 反复调整直到根结点.</li><li>排序输出: 大根堆里堆顶元素一定是最大的, 因此每次输出堆顶元素, 然后把堆顶元素与堆底元素交换, 在把剩余的元素(刚才的堆顶元素已经在堆底, 可调整的元素个数-1)调整成堆, 再次输出堆顶元素, 依次类推, 就是按由大到小的顺序把元素全部输出了.</li></ol></li><li><p>算法描述:</p></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // 创建大根堆</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> buildMaxHeap</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n) {  </span><span style="color:#6A737D;">// n为参与建堆的元素个数</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {      </span><span style="color:#6A737D;">// 从n/2到0, 依次调整</span></span>
<span class="line"><span style="color:#B392F0;">            adjustDown</span><span style="color:#E1E4E8;">(A, i, n);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 向下调整(可用于删除元素)</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> adjustDown</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> k, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n) { </span><span style="color:#6A737D;">// k为要调整结点下标, n为要调整的元素个数</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[k];</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n; i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">) {     </span><span style="color:#6A737D;">// 调整k为根的子树</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (k </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {                           </span><span style="color:#6A737D;">// 如果下标是从0开始的, 则0的左子结点下标为1</span></span>
<span class="line"><span style="color:#E1E4E8;">                i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&lt;</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[i </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">]) {     </span><span style="color:#6A737D;">// 左右子结点中, 取较大的那个结点跟temp比</span></span>
<span class="line"><span style="color:#E1E4E8;">                i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#6A737D;">            // i是左右子结点中较大的那个</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (temp </span><span style="color:#F97583;">&gt;=</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[i]) {                     </span><span style="color:#6A737D;">// temp &gt;= A[i]时, 此时的k是temp应该调整到的位置</span></span>
<span class="line"><span style="color:#F97583;">                break</span><span style="color:#E1E4E8;">;                              </span><span style="color:#6A737D;">// 找到temp该在的位置时, 筛选结束</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {                                </span><span style="color:#6A737D;">// 没找到temp该在的位置时, 还要继续调整</span></span>
<span class="line"><span style="color:#F97583;">                A</span><span style="color:#E1E4E8;">[k] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[i];                        </span><span style="color:#6A737D;">// 先把A[i]调整到父结点上</span></span>
<span class="line"><span style="color:#E1E4E8;">                k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;                              </span><span style="color:#6A737D;">// 修改k值, 以便继续向下筛选</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#6A737D;">// 出了循环, k这颗子树就调整完毕了</span></span>
<span class="line"><span style="color:#F97583;">        A</span><span style="color:#E1E4E8;">[k] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 堆排序</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> heapSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n) {   </span><span style="color:#6A737D;">// 对前n个元素建堆</span></span>
<span class="line"><span style="color:#B392F0;">        buildMaxHeap</span><span style="color:#E1E4E8;">(A, n);                  </span><span style="color:#6A737D;">// 创建初始堆</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {    </span><span style="color:#6A737D;">// n-1趟交换建堆过程</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);        </span><span style="color:#6A737D;">// 输出</span></span>
<span class="line"><span style="color:#B392F0;">            swap</span><span style="color:#E1E4E8;">(A, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, i);                   </span><span style="color:#6A737D;">// 交换堆顶和堆底元素, 为的是把堆底元素撇出去</span></span>
<span class="line"><span style="color:#B392F0;">            adjustDown</span><span style="color:#E1E4E8;">(A, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, i </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);         </span><span style="color:#6A737D;">// 把剩余的 i-1 个元素调整成堆</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);            </span><span style="color:#6A737D;">// 把最后一个元素输出</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>堆的删除和插入 <ol><li>堆顶删除, 把堆顶和堆底交换, 对根结点进行向下调整(剩余元素)</li><li>堆底插入, 再对这个结点进行向上调整. 向上调整的算法如下:</li></ol></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // 向上调整(可用于添加元素)</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> adjustUp</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n) {  </span><span style="color:#6A737D;">// 添加元素只能从堆底添加, n为要调整的元素个数, 所以添加的元素下标k=n-1</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;                      </span><span style="color:#6A737D;">// 新添加元素的下标</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[k];</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;                      </span><span style="color:#6A737D;">// p为双亲结点</span></span>
<span class="line"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (p </span><span style="color:#F97583;">&gt;=</span><span style="color:#79B8FF;"> 0</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[p] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> temp) {     </span><span style="color:#6A737D;">// 若结点大于双亲结点, 则将双亲结点向下调, 并继续向上比较</span></span>
<span class="line"><span style="color:#F97583;">            A</span><span style="color:#E1E4E8;">[k] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[p];                    </span><span style="color:#6A737D;">// 双亲结点下调</span></span>
<span class="line"><span style="color:#E1E4E8;">            k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;                          </span><span style="color:#6A737D;">// 记录调整到的节点位置</span></span>
<span class="line"><span style="color:#E1E4E8;">            p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;                      </span><span style="color:#6A737D;">// 继续向上比较</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (k </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {                   </span><span style="color:#6A737D;">// 下标从0开始的话, 必须有这一步, 不然会出现死循环</span></span>
<span class="line"><span style="color:#F97583;">                break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#6A737D;">// 出循环时的n即为最终应该在的位置</span></span>
<span class="line"><span style="color:#F97583;">        A</span><span style="color:#E1E4E8;">[k] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>添加元素的一个例子:</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Test</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> mainTest</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> A[] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">7</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">9</span><span style="color:#E1E4E8;">};  </span><span style="color:#6A737D;">// 一共10个元素</span></span>
<span class="line"><span style="color:#B392F0;">        buildMaxHeap</span><span style="color:#E1E4E8;">(A, A.length </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);             </span><span style="color:#6A737D;">// 前9个元素建堆</span></span>
<span class="line"><span style="color:#B392F0;">        adjustUp</span><span style="color:#E1E4E8;">(A, A.length);                     </span><span style="color:#6A737D;">// 添加第10个元素(下标为9)进去</span></span>
<span class="line"><span style="color:#6A737D;">        // 排序输出</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A.length </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {   </span><span style="color:#6A737D;">// n-1趟交换建堆过程</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);              </span><span style="color:#6A737D;">// 输出</span></span>
<span class="line"><span style="color:#B392F0;">            swap</span><span style="color:#E1E4E8;">(A, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, i);                         </span><span style="color:#6A737D;">// 交换堆顶和堆底元素, 为的是把堆底元素撇出去</span></span>
<span class="line"><span style="color:#B392F0;">            adjustDown</span><span style="color:#E1E4E8;">(A, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, i </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);               </span><span style="color:#6A737D;">// 把剩余的 i-1 个元素调整成堆</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);                  </span><span style="color:#6A737D;">// 把最后一个元素输出</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>空间复杂度: <code>O(1)</code></li><li>时间复杂度: 建堆<code>O(n)</code>, 调整<code>O(h)</code>, 平均<code>O(nlogn)</code></li><li>稳定性: 不稳定</li></ul><h3 id="归并排序-1" tabindex="-1"><a class="header-anchor" href="#归并排序-1"><span>归并排序</span></a></h3><ul><li>算法思想: 把两个有序表合并成一个有序表</li><li>算法描述:</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // 归并排序 A[left, right]</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> mergeSort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#F97583;">            int</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> right) </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;      </span><span style="color:#6A737D;">// 从中间划分两个序列</span></span>
<span class="line"><span style="color:#B392F0;">            mergeSort</span><span style="color:#E1E4E8;">(A, left, mid);           </span><span style="color:#6A737D;">// 左边递归排序</span></span>
<span class="line"><span style="color:#B392F0;">            mergeSort</span><span style="color:#E1E4E8;">(A, mid </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, right);      </span><span style="color:#6A737D;">// 右边递归排序</span></span>
<span class="line"><span style="color:#B392F0;">            merge</span><span style="color:#E1E4E8;">(A, left, mid, right);        </span><span style="color:#6A737D;">// 归并</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // A[left, mid] 和 A[mid+1, right] 各自有序, 把他们合并成一个有序表</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> merge</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> mid, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> i, j, k;</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> B[] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;">[A.length];  </span><span style="color:#6A737D;">// 这是个辅助单元</span></span>
<span class="line"><span style="color:#6A737D;">        // 把A[left, right]复制到B中</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> left; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> right; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">            B</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#6A737D;">        // i表示左边, j表示右边, k表示合并后的下标</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> left, j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> right; k</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">B</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&lt;</span><span style="color:#F97583;"> B</span><span style="color:#E1E4E8;">[j]) {  </span><span style="color:#6A737D;">// 比较B左右两端中的元素大小, 小的复制到A中</span></span>
<span class="line"><span style="color:#F97583;">                A</span><span style="color:#E1E4E8;">[k] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> B</span><span style="color:#E1E4E8;">[i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">                A</span><span style="color:#E1E4E8;">[k] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> B</span><span style="color:#E1E4E8;">[j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#6A737D;">        // 若左边未复制完, 复制</span></span>
<span class="line"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> mid) {</span></span>
<span class="line"><span style="color:#F97583;">            A</span><span style="color:#E1E4E8;">[k</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> B</span><span style="color:#E1E4E8;">[i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#6A737D;">        // 若右边未复制完, 复制</span></span>
<span class="line"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#F97583;">            A</span><span style="color:#E1E4E8;">[k</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> B</span><span style="color:#E1E4E8;">[j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>空间复杂度: <code>O(n)</code></li><li>时间复杂度: <code>O(nlogn)</code>, <code>2路归并</code>底数为<code>2</code>, <code>K路归并</code>底数为<code>k</code></li><li>稳定性: 稳定</li></ul>`,53),c=[o];function i(r,t){return a(),n("div",null,c)}const d=s(e,[["render",i],["__file","2017-05-18-排序算法.html.vue"]]),v=JSON.parse('{"path":"/algorithm/2017-05-18-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html","title":"排序算法","lang":"zh-CN","frontmatter":{"title":"排序算法","date":"2017-05-18T00:00:00.000Z","category":"Algorithm","tag":["算法"],"order":-20170518,"description":"常见排序算法的分类 插入类排序 基本思想：每次将一个元素插入到前面已经排好序的子序列中 主要包括：直接插入排序、折半插入排序 交换类排序 基本思想：根据两个元素的比较结果来交换两个元素在序列中的位置。 主要包括：冒泡排序、快速排序 选择类排序 基本思想：每趟都从待排序列中选取一个最小值作为序列的第i个元素,直到第n-1趟，待排序列只剩下一个元素。 主要...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/algorithm/2017-05-18-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"排序算法"}],["meta",{"property":"og:description","content":"常见排序算法的分类 插入类排序 基本思想：每次将一个元素插入到前面已经排好序的子序列中 主要包括：直接插入排序、折半插入排序 交换类排序 基本思想：根据两个元素的比较结果来交换两个元素在序列中的位置。 主要包括：冒泡排序、快速排序 选择类排序 基本思想：每趟都从待排序列中选取一个最小值作为序列的第i个元素,直到第n-1趟，待排序列只剩下一个元素。 主要..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-24T01:13:34.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2017-05-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-24T01:13:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"排序算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2017-05-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-24T01:13:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":3,"title":"插入类排序","slug":"插入类排序","link":"#插入类排序","children":[]},{"level":3,"title":"交换类排序","slug":"交换类排序","link":"#交换类排序","children":[]},{"level":3,"title":"选择类排序","slug":"选择类排序","link":"#选择类排序","children":[]},{"level":2,"title":"直接插入排序","slug":"直接插入排序","link":"#直接插入排序","children":[]},{"level":2,"title":"折半插入排序","slug":"折半插入排序","link":"#折半插入排序","children":[]},{"level":2,"title":"冒泡排序","slug":"冒泡排序","link":"#冒泡排序","children":[]},{"level":2,"title":"快速排序","slug":"快速排序","link":"#快速排序","children":[]},{"level":2,"title":"简单选择排序","slug":"简单选择排序","link":"#简单选择排序","children":[]},{"level":2,"title":"堆排序","slug":"堆排序","link":"#堆排序","children":[]},{"level":2,"title":"归并排序","slug":"归并排序","link":"#归并排序","children":[{"level":3,"title":"堆排序","slug":"堆排序-1","link":"#堆排序-1","children":[]},{"level":3,"title":"归并排序","slug":"归并排序-1","link":"#归并排序-1","children":[]}]}],"git":{"createdTime":1719191614000,"updatedTime":1719191614000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"algorithm/2017-05-18-排序算法.md","localizedDate":"2017年5月18日","excerpt":"","autoDesc":true}');export{d as comp,v as data};
