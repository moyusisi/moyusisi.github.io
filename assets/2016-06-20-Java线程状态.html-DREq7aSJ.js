import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o,d as t}from"./app-Cd603RD0.js";const s="/assets/system_thread-msN2EVY5.png",c="/assets/java_thread-BXwbNLGC.png",n={},d=t('<p>java线程状态详解</p><h2 id="进程三态模型" tabindex="-1"><a class="header-anchor" href="#进程三态模型"><span>进程三态模型</span></a></h2><p>操作系统中有比较经典的进程三态模型, 各状态之间的转换关系如下图:</p><figure><img src="'+s+`" alt="进程三态模型" tabindex="0" loading="lazy"><figcaption>进程三态模型</figcaption></figure><h2 id="java线程状态" tabindex="-1"><a class="header-anchor" href="#java线程状态"><span>Java线程状态</span></a></h2><p>类<code>java.long.Thread</code>中有个内部的枚举类<code>State</code>用来表示线程的状态, 它的定义如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> enum</span><span style="color:#B392F0;"> State</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#79B8FF;">    NEW</span><span style="color:#E1E4E8;">,      </span><span style="color:#6A737D;">// 刚创建, 还没启动</span></span>
<span class="line"><span style="color:#79B8FF;">    RUNNABLE</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 可运行状态</span></span>
<span class="line"><span style="color:#79B8FF;">    BLOCKED</span><span style="color:#E1E4E8;">,  </span><span style="color:#6A737D;">// 阻塞态, 或被挂起</span></span>
<span class="line"><span style="color:#79B8FF;">    WAITING</span><span style="color:#E1E4E8;">,  </span><span style="color:#6A737D;">// 等待锁的状态</span></span>
<span class="line"><span style="color:#79B8FF;">    TIMED_WAITING</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 等待时间的状态, 如sleep就在等待时间</span></span>
<span class="line"><span style="color:#79B8FF;">    TERMINATED</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 终止态</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="线程状态解释" tabindex="-1"><a class="header-anchor" href="#线程状态解释"><span>线程状态解释</span></a></h3><ul><li><code>NEW</code>: 线程还没被<code>start()</code>启动. 调用了<code>start()</code>状态也不一定会立即改变, 中间还有一些步骤.</li><li><code>RUNNABLE</code>: <code>NEW</code>状态的线程<code>start()</code>结束后会进入<code>RUNNABLE</code>状态. 正在运行的线程一定处于<code>RUNNABLE</code>状态, 使用<code>Thread.currentThread().getState()</code>只会得到<code>RUNNABLE</code>. 处于<code>RUNNABLE</code>状态的线程并不一定在<code>运行</code>. 比如当线程发生了<code>yield()</code>操作时, 该线程仍然是<code>RUNNABLE</code>状态, 要是对应到操作系统中的三态模型就该算是<code>就绪</code>了; 再比如, 在BIO中, 线程正在网络等待时, 现成的状态仍然时<code>RUNNABLE</code>, 而在底层实际上已经被阻塞了.</li><li><code>BLOCKED</code>: 阻塞态, 原因通常是在等待某个<code>锁</code>, 当某个<code>synchronized</code>正好有线程正在使用, 另一个线程尝试进入该<code>临界区</code>的时候就会被阻塞. 得到锁(比如另一个线程走完了临界区或发生了相应锁对象的<code>wait()</code>操作)之后状态会由<code>BLOCKED</code>恢复到<code>RUNNABLE</code>.</li><li><code>WAITING</code>: 这种状态通常是调用某个<code>锁对象</code>的<code>wait()</code>方法的结果, 类似的有<code>Thread.join()</code>. 跟<code>BLOCKED</code>不同, <code>BLOCKED</code>是表示不能进入临界区, 所以在等待; <code>WAITING</code>是已经进入了临界区, 或者可理解为已经在运行了, 然后发现缺少某些资源(锁对象), 放弃运行权, 等待资源准备好. 对某个锁对象<code>notify()</code>时, 将从等待池中唤醒一个<code>WAITING</code>状态的线程恢复到<code>RUNNABLE</code>状态</li><li><code>TIMED_WAITING</code>: 跟<code>WAITING</code>不一样的地方是, <code>WAITING</code>等待锁对象,它等待的是时间, 比如使用<code>Thread.sleep()</code>相当于把时间资源作为所对象. 时间到达时触发线程回到工作状态.</li><li><code>TERMINATED</code>: 线程结束了,<code>run()</code>方法跑完了. 这是Java的一种状态,在操作系统内部可能线程已经注销了.</li></ul><h3 id="状态转换图" tabindex="-1"><a class="header-anchor" href="#状态转换图"><span>状态转换图</span></a></h3><figure><img src="`+c+'" alt="进程三态模型" tabindex="0" loading="lazy"><figcaption>进程三态模型</figcaption></figure>',11),l=[d];function i(r,p){return o(),a("div",null,l)}const v=e(n,[["render",i],["__file","2016-06-20-Java线程状态.html.vue"]]),E=JSON.parse('{"path":"/program/backend/2016-06-20-Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.html","title":"Java线程状态","lang":"zh-CN","frontmatter":{"title":"Java线程状态","date":"2016-06-20T00:00:00.000Z","category":"Java","tag":["Java"],"order":-20160620,"description":"java线程状态详解 进程三态模型 操作系统中有比较经典的进程三态模型, 各状态之间的转换关系如下图: 进程三态模型进程三态模型 Java线程状态 类java.long.Thread中有个内部的枚举类State用来表示线程的状态, 它的定义如下: 线程状态解释 NEW: 线程还没被start()启动. 调用了start()状态也不一定会立即改变, 中间...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/backend/2016-06-20-Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"Java线程状态"}],["meta",{"property":"og:description","content":"java线程状态详解 进程三态模型 操作系统中有比较经典的进程三态模型, 各状态之间的转换关系如下图: 进程三态模型进程三态模型 Java线程状态 类java.long.Thread中有个内部的枚举类State用来表示线程的状态, 它的定义如下: 线程状态解释 NEW: 线程还没被start()启动. 调用了start()状态也不一定会立即改变, 中间..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T16:05:57.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2016-06-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-23T16:05:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java线程状态\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-06-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-23T16:05:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"进程三态模型","slug":"进程三态模型","link":"#进程三态模型","children":[]},{"level":2,"title":"Java线程状态","slug":"java线程状态","link":"#java线程状态","children":[{"level":3,"title":"线程状态解释","slug":"线程状态解释","link":"#线程状态解释","children":[]},{"level":3,"title":"状态转换图","slug":"状态转换图","link":"#状态转换图","children":[]}]}],"git":{"createdTime":1719158757000,"updatedTime":1719158757000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/backend/2016-06-20-Java线程状态.md","localizedDate":"2016年6月20日","excerpt":"","autoDesc":true}');export{v as comp,E as data};
