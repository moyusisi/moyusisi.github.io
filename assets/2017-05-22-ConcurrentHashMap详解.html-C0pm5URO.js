import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as a,d as l}from"./app-J8acWEVP.js";const e="/assets/ConcurrentHashMap-DrvcIIAF.png",p={},o=l('<p><code>HashMap</code>是非线程安全的, 对应的线程安全版本是<code>HashTable</code>, 但<code>HashTable</code>加锁的粒度大,<code>synchronized</code>是针对整个哈希表的, 效率低. 后来<code>JDK1.5</code>出现了<code>ConcurrentHashMap</code>, 通过引入<code>Segment</code>进行分段加锁, 从而提高并发效率.</p><h2 id="存储结构" tabindex="-1"><a class="header-anchor" href="#存储结构"><span>存储结构</span></a></h2><p><code>HashMap</code>的数据结构是数组加链表的形式。结构大体如下:</p><figure><img src="'+e+`" alt="ConcurrentHashMap结构图" tabindex="0" loading="lazy"><figcaption>ConcurrentHashMap结构图</figcaption></figure><p>可以看出<code>ConcurrentHashMap</code>有点像把<code>HashTable</code>又包了一层, 把<code>table</code>放到了<code>segments</code>里, 这样同步锁是在每一个<code>segment</code>里的, 只要多个修改操作发生在不同的段上, 它们就可以并发进行. 我们为了区分, 把每个元素<code>segment</code>成为<code>段</code>(有的文章里称作<code>桶</code>), 把<code>segment</code>里面的<code>table</code>的单个元素成为<code>桶</code>.</p><p>我们来看看<code>Segment</code>的结构, 跟<code>HashMap</code>里的结构非常类似:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> Segment</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">extends</span><span style="color:#B392F0;"> ReentrantLock</span><span style="color:#F97583;"> implements</span><span style="color:#B392F0;"> Serializable</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">        transient</span><span style="color:#F97583;"> volatile</span><span style="color:#E1E4E8;"> HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;[] table; </span><span style="color:#6A737D;">// 桶, 除了类型, 其他跟HashMap里的table一样</span></span>
<span class="line"><span style="color:#F97583;">        transient</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> count;     </span><span style="color:#6A737D;">// HashEntry的总个数, 对应HashMap里的size</span></span>
<span class="line"><span style="color:#F97583;">        transient</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> modCount;  </span><span style="color:#6A737D;">// 同HashMap</span></span>
<span class="line"><span style="color:#F97583;">        transient</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> threshold; </span><span style="color:#6A737D;">// 同HashMap, 用于rehash, rehash时只会改变table的大小, segments大小确定之后就不会再变了</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="需要知道的概念" tabindex="-1"><a class="header-anchor" href="#需要知道的概念"><span>需要知道的概念</span></a></h2><p><code>ConcurrentHashMap</code>比<code>HashMap</code>多了一层, 新增了几个概念:</p><ul><li><code>segments</code>: 一个数组, 可称为<code>段</code>, 该数组的大小总是<code>2的n次幂</code>, 默认是16</li><li><code>concurrencyLevel</code>: 并发等级, 实际上就是<code>segments</code>数组的大小, 一旦确定就不再改变, 扩容时不会增加Segment的数量, 而只会增加<code>Segment</code>中链表数组(<code>table</code>)的容量大小</li><li><code>segmentShift</code>: 假设<code>segments</code>的大小是<code>2的n次方</code>, 则<code>segmentShift = 32-n</code></li><li><code>segmentMask</code>: 用于计算在<code>segments</code>中下标的掩码, 假设<code>segments</code>的大小是<code>2的n次方</code>, 则<code>segmentMask = 2的n次方-1</code></li></ul><h2 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法"><span>构造方法</span></a></h2><p><code>ConcurrentHashMap</code>有重载了5个构造方法, 实现都是类似的, 直接从代码中解释</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    public</span><span style="color:#B392F0;"> ConcurrentHashMap</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> initialCapacity, </span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;"> loadFactor, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> concurrencyLevel) {</span></span>
<span class="line"><span style="color:#F97583;">       if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">(loadFactor </span><span style="color:#F97583;">&gt;</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> initialCapacity </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> 0</span><span style="color:#F97583;"> ||</span><span style="color:#E1E4E8;"> concurrencyLevel </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">           throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> IllegalArgumentException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">       if</span><span style="color:#E1E4E8;"> (concurrencyLevel </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> MAX_SEGMENTS)</span></span>
<span class="line"><span style="color:#E1E4E8;">           concurrencyLevel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> MAX_SEGMENTS;</span></span>
<span class="line"><span style="color:#6A737D;">       // Find power-of-two sizes best matching arguments</span></span>
<span class="line"><span style="color:#F97583;">       int</span><span style="color:#E1E4E8;"> sshift </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">       int</span><span style="color:#E1E4E8;"> ssize </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">       while</span><span style="color:#E1E4E8;"> (ssize </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> concurrencyLevel) {</span></span>
<span class="line"><span style="color:#F97583;">           ++</span><span style="color:#E1E4E8;">sshift;     </span><span style="color:#6A737D;">// 移位的次数</span></span>
<span class="line"><span style="color:#E1E4E8;">           ssize </span><span style="color:#F97583;">&lt;&lt;=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// segments的size, 数值上为大于等于concurrencyLevel的最小的那个 2的n次幂</span></span>
<span class="line"><span style="color:#E1E4E8;">       }</span></span>
<span class="line"><span style="color:#79B8FF;">       this</span><span style="color:#E1E4E8;">.segmentShift </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 32</span><span style="color:#F97583;"> -</span><span style="color:#E1E4E8;"> sshift;</span></span>
<span class="line"><span style="color:#79B8FF;">       this</span><span style="color:#E1E4E8;">.segmentMask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ssize </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">       if</span><span style="color:#E1E4E8;"> (initialCapacity </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> MAXIMUM_CAPACITY)</span></span>
<span class="line"><span style="color:#E1E4E8;">           initialCapacity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> MAXIMUM_CAPACITY;</span></span>
<span class="line"><span style="color:#F97583;">       int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> initialCapacity </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> ssize;       </span><span style="color:#6A737D;">// 默认的情况下 c = 16/16 = 1</span></span>
<span class="line"><span style="color:#F97583;">       if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> ssize </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> initialCapacity)</span></span>
<span class="line"><span style="color:#F97583;">           ++</span><span style="color:#E1E4E8;">c;                               </span><span style="color:#6A737D;">// c是并发等级的向上取整倍</span></span>
<span class="line"><span style="color:#F97583;">       int</span><span style="color:#E1E4E8;"> cap </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> MIN_SEGMENT_TABLE_CAPACITY;  </span><span style="color:#6A737D;">// tables的容量, 最少为2</span></span>
<span class="line"><span style="color:#F97583;">       while</span><span style="color:#E1E4E8;"> (cap </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> c)</span></span>
<span class="line"><span style="color:#E1E4E8;">           cap </span><span style="color:#F97583;">&lt;&lt;=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;                         </span><span style="color:#6A737D;">// 容量是比c大的最小2次幂, 最小为2, 默认也为2</span></span>
<span class="line"><span style="color:#6A737D;">       // 创建segments[0]</span></span>
<span class="line"><span style="color:#E1E4E8;">       Segment&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; s0 </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#F97583;">           new</span><span style="color:#E1E4E8;"> Segment&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;(loadFactor, (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">)(cap </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> loadFactor),   </span><span style="color:#6A737D;">// loadFactor, threshold</span></span>
<span class="line"><span style="color:#E1E4E8;">                            (HashEntry</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">[])</span><span style="color:#F97583;">new</span><span style="color:#F97583;"> HashEntry</span><span style="color:#E1E4E8;">[cap]); </span><span style="color:#6A737D;">// 这个Segment中的tables也直接创建了, 注意默认情况下tables的每个桶中只有2个结点</span></span>
<span class="line"><span style="color:#E1E4E8;">       Segment&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;[] ss </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (Segment</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">[])</span><span style="color:#F97583;">new</span><span style="color:#F97583;"> Segment</span><span style="color:#E1E4E8;">[ssize];  </span><span style="color:#6A737D;">// 创建segments, 这里可以看出ssize是真正的并发等级</span></span>
<span class="line"><span style="color:#E1E4E8;">       UNSAFE.</span><span style="color:#B392F0;">putOrderedObject</span><span style="color:#E1E4E8;">(ss, SBASE, s0); </span><span style="color:#6A737D;">// 只有segments[0]有值, 这是为了给创建其他位置的segment时提供模板</span></span>
<span class="line"><span style="color:#79B8FF;">       this</span><span style="color:#E1E4E8;">.segments </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ss;</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="关于hash定位" tabindex="-1"><a class="header-anchor" href="#关于hash定位"><span>关于hash定位</span></a></h2><p><code>ConcurrentHashMap</code>中的定位分两部分, 一部分是定位段<code>segments</code>, 一部分是定位桶<code>table</code>, 两个都直接使用<code>key</code>的哈希值<code>hash</code>进行定位; 段<code>segments</code>通过<code>hash</code>的高位定位, 桶<code>table</code>通过<code>hash</code>的低位定位.</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // 定位段: hash值无符号右移(32-n)位, 比如默认16时, n=4; 然后再与低n位按位与, 就得到了在段中的位置j</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (hash </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#E1E4E8;"> segmentShift) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> segmentMask;</span></span>
<span class="line"><span style="color:#6A737D;">    // 获取segment的函数</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> Segment</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#B392F0;"> segmentForHash</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> h) {</span></span>
<span class="line"><span style="color:#6A737D;">        // SBASE为数组中第一个元素的偏移地址, SSHIFT为数组寻址的换算因子, 两个必须配合使用</span></span>
<span class="line"><span style="color:#6A737D;">        // 这两行代码相当于在segments中获取下标为j的Segment</span></span>
<span class="line"><span style="color:#F97583;">        long</span><span style="color:#E1E4E8;"> u </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (((h </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#E1E4E8;"> segmentShift) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> segmentMask) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> SSHIFT) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> SBASE;</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> (Segment</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">) UNSAFE.</span><span style="color:#B392F0;">getObjectVolatile</span><span style="color:#E1E4E8;">(segments, u);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 定位桶: hash直接取低位和(table的长度-1)按位与, 就得到了在桶中的下标index</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (tab.length </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> hash;</span></span>
<span class="line"><span style="color:#E1E4E8;">    HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; first </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> entryAt</span><span style="color:#E1E4E8;">(tab, index);  </span><span style="color:#6A737D;">// 获取桶中下标为index的结点</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="添加元素put" tabindex="-1"><a class="header-anchor" href="#添加元素put"><span>添加元素put</span></a></h2><ul><li>刚创建的<code>ConcurrentHashMap</code>中的<code>segments</code>只有位置<code>0</code>不为空, 其他位置还没创建<code>Segment</code></li><li>添加元素时, 若对应位置的段<code>segment</code>为<code>null</code>则先创建<code>segment</code></li><li>添加元素时, 先定位到段<code>segment</code>, 再转化为<code>segment.put()</code></li><li><code>segments</code>的大小不再改变, 涉及扩容时, 只有<code>table</code>大小会变</li><li><code>put</code>操作时要在对应的<code>segment</code>上加锁</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // ConcurrentHashMap的put,外层不加锁, 段内加锁</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(K key, V value) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Segment&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; s;</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (value </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">            throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> NullPointerException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(key);                            </span><span style="color:#6A737D;">// 获取key的哈希值</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (hash </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#E1E4E8;"> segmentShift) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> segmentMask;   </span><span style="color:#6A737D;">// 段索引</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> ((s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (Segment</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">)UNSAFE.getObject          </span><span style="color:#6A737D;">// 获取j位置的Segment, 如果为null, 则创建</span></span>
<span class="line"><span style="color:#E1E4E8;">             (segments, (j </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> SSHIFT) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> SBASE)) </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            s </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> ensureSegment</span><span style="color:#E1E4E8;">(j);                        </span><span style="color:#6A737D;">// 在ensureSegment还要多次检查取保不为null才会真正创建, 并且通过CAS赋值, 创建时, cap, loadFactor和threshold都是以s0为模板创建的</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(key, hash, value, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);           </span><span style="color:#6A737D;">// 转嫁给了Segment的put</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // Segment的put, 这里面才会加锁</span></span>
<span class="line"><span style="color:#F97583;">    final</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(K key, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> hash, V value, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> onlyIfAbsent) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; node </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> tryLock</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">?</span><span style="color:#79B8FF;"> null</span><span style="color:#F97583;"> :</span><span style="color:#6A737D;">  // 尝试加锁, 加锁成功返回true, 否则返回false</span></span>
<span class="line"><span style="color:#B392F0;">            scanAndLockForPut</span><span style="color:#E1E4E8;">(key, hash, value);  </span><span style="color:#6A737D;">// 加锁失败时, 循环尝试加锁, 试几次后, 阻塞等待加锁(这个函数中还试图创建HashEntry)</span></span>
<span class="line"><span style="color:#E1E4E8;">        V oldValue;</span></span>
<span class="line"><span style="color:#F97583;">        try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;[] tab </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table;</span></span>
<span class="line"><span style="color:#F97583;">            int</span><span style="color:#E1E4E8;"> index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (tab.length </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> hash;  </span><span style="color:#6A737D;">// 桶下标</span></span>
<span class="line"><span style="color:#E1E4E8;">            HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; first </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> entryAt</span><span style="color:#E1E4E8;">(tab, index);  </span><span style="color:#6A737D;">// table的index位置的元素</span></span>
<span class="line"><span style="color:#F97583;">            for</span><span style="color:#E1E4E8;"> (HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> first;;) {  </span><span style="color:#6A737D;">// 死循环, 只能从里面跳出</span></span>
<span class="line"><span style="color:#F97583;">                if</span><span style="color:#E1E4E8;"> (e </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {    </span><span style="color:#6A737D;">// 桶中已有其他结点, 找是否key已存在</span></span>
<span class="line"><span style="color:#E1E4E8;">                    K k;</span></span>
<span class="line"><span style="color:#F97583;">                    if</span><span style="color:#E1E4E8;"> ((k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.key) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">||</span><span style="color:#6A737D;">    // 如果key一样, 覆盖原值, 跳出循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                        (e.hash </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> key.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(k))) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        oldValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.value;      </span><span style="color:#6A737D;">// 记录被替换掉的旧值</span></span>
<span class="line"><span style="color:#F97583;">                        if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">onlyIfAbsent) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                            e.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> value;    </span><span style="color:#6A737D;">// 覆盖原值</span></span>
<span class="line"><span style="color:#F97583;">                            ++</span><span style="color:#E1E4E8;">modCount;</span></span>
<span class="line"><span style="color:#E1E4E8;">                        }</span></span>
<span class="line"><span style="color:#F97583;">                        break</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">//  跳出循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }  </span><span style="color:#6A737D;">// key 不一样就向后移动</span></span>
<span class="line"><span style="color:#E1E4E8;">                    e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.next;  </span><span style="color:#6A737D;">// 向后移动</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#F97583;">                else</span><span style="color:#E1E4E8;"> {  </span><span style="color:#6A737D;">// 桶中还没结点</span></span>
<span class="line"><span style="color:#F97583;">                    if</span><span style="color:#E1E4E8;"> (node </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)  </span><span style="color:#6A737D;">// 如果新加的结点已经创建好了, next字段指向first</span></span>
<span class="line"><span style="color:#E1E4E8;">                        node.</span><span style="color:#B392F0;">setNext</span><span style="color:#E1E4E8;">(first);</span></span>
<span class="line"><span style="color:#F97583;">                    else</span><span style="color:#6A737D;">  // 没创建好则创建一个, 也是next字段指向first</span></span>
<span class="line"><span style="color:#E1E4E8;">                        node </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#E1E4E8;"> HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;(hash, key, value, first);</span></span>
<span class="line"><span style="color:#F97583;">                    int</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> count </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 结点数量+1</span></span>
<span class="line"><span style="color:#F97583;">                    if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> threshold </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> tab.length </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> MAXIMUM_CAPACITY)  </span><span style="color:#6A737D;">// 看是否需要扩容</span></span>
<span class="line"><span style="color:#B392F0;">                        rehash</span><span style="color:#E1E4E8;">(node);  </span><span style="color:#6A737D;">// 扩容</span></span>
<span class="line"><span style="color:#F97583;">                    else</span></span>
<span class="line"><span style="color:#B392F0;">                        setEntryAt</span><span style="color:#E1E4E8;">(tab, index, node);  </span><span style="color:#6A737D;">// 头插, 放到桶位置的链表头</span></span>
<span class="line"><span style="color:#F97583;">                    ++</span><span style="color:#E1E4E8;">modCount;  </span><span style="color:#6A737D;">// 修改次数加一</span></span>
<span class="line"><span style="color:#E1E4E8;">                    count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c;   </span><span style="color:#6A737D;">// 记录结点数量</span></span>
<span class="line"><span style="color:#E1E4E8;">                    oldValue </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 新结点, 被替换掉的旧值为null</span></span>
<span class="line"><span style="color:#F97583;">                    break</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 跳出循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">            unlock</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 重入锁一般都会在finally中解锁, 否则很容易发生死锁</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> oldValue;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="删除元素remove" tabindex="-1"><a class="header-anchor" href="#删除元素remove"><span>删除元素remove</span></a></h2><ul><li>remove元素也是先定位到段<code>segment</code>, 再转化为<code>segment.remove()</code></li><li><code>remove</code>操作时也要在相应的<code>segment</code>上加锁</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // 外层remove加锁</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(Object key) {</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Segment&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; s </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> segmentForHash</span><span style="color:#E1E4E8;">(hash);  </span><span style="color:#6A737D;">// 定位段</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#F97583;"> ?</span><span style="color:#79B8FF;"> null</span><span style="color:#F97583;"> :</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(key, hash, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 转交给段remove</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 段内的remove, 需要加锁</span></span>
<span class="line"><span style="color:#F97583;">    final</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(Object key, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> hash, Object value) {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">tryLock</span><span style="color:#E1E4E8;">())   </span><span style="color:#6A737D;">// 先加锁</span></span>
<span class="line"><span style="color:#B392F0;">            scanAndLock</span><span style="color:#E1E4E8;">(key, hash);</span></span>
<span class="line"><span style="color:#E1E4E8;">        V oldValue </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;[] tab </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table;           </span><span style="color:#6A737D;">// 桶</span></span>
<span class="line"><span style="color:#F97583;">            int</span><span style="color:#E1E4E8;"> index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (tab.length </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> hash;    </span><span style="color:#6A737D;">// 桶下标</span></span>
<span class="line"><span style="color:#E1E4E8;">            HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> entryAt</span><span style="color:#E1E4E8;">(tab, index); </span><span style="color:#6A737D;">// 桶中链表头</span></span>
<span class="line"><span style="color:#E1E4E8;">            HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; pred </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;             </span><span style="color:#6A737D;">// 前驱结点</span></span>
<span class="line"><span style="color:#F97583;">            while</span><span style="color:#E1E4E8;"> (e </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                K k;</span></span>
<span class="line"><span style="color:#E1E4E8;">                HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.next;</span></span>
<span class="line"><span style="color:#F97583;">                if</span><span style="color:#E1E4E8;"> ((k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.key) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">                    (e.hash </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> key.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(k))) {  </span><span style="color:#6A737D;">// 如果key一样</span></span>
<span class="line"><span style="color:#E1E4E8;">                    V v </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.value;</span></span>
<span class="line"><span style="color:#F97583;">                    if</span><span style="color:#E1E4E8;"> (value </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#F97583;"> ||</span><span style="color:#E1E4E8;"> value </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> v </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> value.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(v)) {  </span><span style="color:#6A737D;">// 找到待删除的结点</span></span>
<span class="line"><span style="color:#F97583;">                        if</span><span style="color:#E1E4E8;"> (pred </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)  </span><span style="color:#6A737D;">// 前驱结点为空, 说明表头应该被删除,直接把e.next作为表头</span></span>
<span class="line"><span style="color:#B392F0;">                            setEntryAt</span><span style="color:#E1E4E8;">(tab, index, next);</span></span>
<span class="line"><span style="color:#F97583;">                        else</span></span>
<span class="line"><span style="color:#E1E4E8;">                            pred.</span><span style="color:#B392F0;">setNext</span><span style="color:#E1E4E8;">(next); </span><span style="color:#6A737D;">// 前驱结点不为空, 前驱结点直接指向e.next</span></span>
<span class="line"><span style="color:#F97583;">                        ++</span><span style="color:#E1E4E8;">modCount;   </span><span style="color:#6A737D;">// 修改次数+1</span></span>
<span class="line"><span style="color:#F97583;">                        --</span><span style="color:#E1E4E8;">count;      </span><span style="color:#6A737D;">// 结点数量-1</span></span>
<span class="line"><span style="color:#E1E4E8;">                        oldValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> v; </span><span style="color:#6A737D;">// 记录旧值</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#F97583;">                    break</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 找到并删除节点后, 跳出循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                pred </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e; </span><span style="color:#6A737D;">// 前驱结点后移</span></span>
<span class="line"><span style="color:#E1E4E8;">                e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next; </span><span style="color:#6A737D;">// 待比较结点后移</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">            unlock</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">// finally中解锁</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> oldValue;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="获取元素get" tabindex="-1"><a class="header-anchor" href="#获取元素get"><span>获取元素get</span></a></h2><ul><li><code>get</code>操作不需要加锁(弱一致性)</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(Object key) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Segment&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; s;        </span><span style="color:#6A737D;">// 段</span></span>
<span class="line"><span style="color:#E1E4E8;">        HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;[] tab;  </span><span style="color:#6A737D;">// 段内table</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(key);     </span><span style="color:#6A737D;">// hash值</span></span>
<span class="line"><span style="color:#F97583;">        long</span><span style="color:#E1E4E8;"> u </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (((h </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#E1E4E8;"> segmentShift) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> segmentMask) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> SSHIFT) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> SBASE;</span></span>
<span class="line"><span style="color:#6A737D;">        // 对应的段和段内桶都不为null</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> ((s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (Segment</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">)UNSAFE.</span><span style="color:#B392F0;">getObjectVolatile</span><span style="color:#E1E4E8;">(segments, u)) </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#F97583;"> &amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">            (tab </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s.table) </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">            // 从桶中链表头开始, 不断向后查找</span></span>
<span class="line"><span style="color:#6A737D;">            // 这个get只保证了读取链表头的时候是一个原子操作, 但是有可能读出表头之后, 表头被别的线程删除了</span></span>
<span class="line"><span style="color:#6A737D;">            // 因此get返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现</span></span>
<span class="line"><span style="color:#6A737D;">            // 如果要求强一致性，那么必须使用Collections.synchronizedMap()方法</span></span>
<span class="line"><span style="color:#F97583;">            for</span><span style="color:#E1E4E8;"> (HashEntry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (HashEntry</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">) UNSAFE.getObjectVolatile</span></span>
<span class="line"><span style="color:#E1E4E8;">                     (tab, ((</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;">)(((tab.length </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> h)) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> TSHIFT) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> TBASE);</span></span>
<span class="line"><span style="color:#E1E4E8;">                 e </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">; e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.next) {</span></span>
<span class="line"><span style="color:#6A737D;">                // 刚到这里就有可能e结点已经被别的线程删除了(弱一致性)</span></span>
<span class="line"><span style="color:#E1E4E8;">                K k;</span></span>
<span class="line"><span style="color:#F97583;">                if</span><span style="color:#E1E4E8;"> ((k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.key) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (e.hash </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> key.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(k)))</span></span>
<span class="line"><span style="color:#F97583;">                    return</span><span style="color:#E1E4E8;"> e.value;  </span><span style="color:#6A737D;">// 如果key一样就返回</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="锁全段操作size-containsvalue" tabindex="-1"><a class="header-anchor" href="#锁全段操作size-containsvalue"><span>锁全段操作size/containsValue</span></a></h2><ul><li><code>size</code>和<code>containsValue</code>操作的代价比较大, 需要锁住所有的段</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // 两个操作里都有这段代码, 把所有的段都加锁</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> segments.length; </span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">j)</span></span>
<span class="line"><span style="color:#B392F0;">        ensureSegment</span><span style="color:#E1E4E8;">(j).</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// force creation</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,28),c=[o];function t(r,E){return n(),a("div",null,c)}const d=s(p,[["render",t],["__file","2017-05-22-ConcurrentHashMap详解.html.vue"]]),v=JSON.parse('{"path":"/program/java/2017-05-22-ConcurrentHashMap%E8%AF%A6%E8%A7%A3.html","title":"ConcurrentHashMap详解","lang":"zh-CN","frontmatter":{"title":"ConcurrentHashMap详解","date":"2017-05-22T00:00:00.000Z","category":"Java","tag":["Java"],"order":-20170522,"description":"HashMap是非线程安全的, 对应的线程安全版本是HashTable, 但HashTable加锁的粒度大,synchronized是针对整个哈希表的, 效率低. 后来JDK1.5出现了ConcurrentHashMap, 通过引入Segment进行分段加锁, 从而提高并发效率. 存储结构 HashMap的数据结构是数组加链表的形式。结构大体如下: C...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/java/2017-05-22-ConcurrentHashMap%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"ConcurrentHashMap详解"}],["meta",{"property":"og:description","content":"HashMap是非线程安全的, 对应的线程安全版本是HashTable, 但HashTable加锁的粒度大,synchronized是针对整个哈希表的, 效率低. 后来JDK1.5出现了ConcurrentHashMap, 通过引入Segment进行分段加锁, 从而提高并发效率. 存储结构 HashMap的数据结构是数组加链表的形式。结构大体如下: C..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-09T09:40:25.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2017-05-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-09T09:40:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ConcurrentHashMap详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2017-05-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-09T09:40:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"存储结构","slug":"存储结构","link":"#存储结构","children":[]},{"level":2,"title":"需要知道的概念","slug":"需要知道的概念","link":"#需要知道的概念","children":[]},{"level":2,"title":"构造方法","slug":"构造方法","link":"#构造方法","children":[]},{"level":2,"title":"关于hash定位","slug":"关于hash定位","link":"#关于hash定位","children":[]},{"level":2,"title":"添加元素put","slug":"添加元素put","link":"#添加元素put","children":[]},{"level":2,"title":"删除元素remove","slug":"删除元素remove","link":"#删除元素remove","children":[]},{"level":2,"title":"获取元素get","slug":"获取元素get","link":"#获取元素get","children":[]},{"level":2,"title":"锁全段操作size/containsValue","slug":"锁全段操作size-containsvalue","link":"#锁全段操作size-containsvalue","children":[]}],"git":{"createdTime":1719160919000,"updatedTime":1725874825000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/java/2017-05-22-ConcurrentHashMap详解.md","localizedDate":"2017年5月22日","excerpt":"","autoDesc":true}');export{d as comp,v as data};
