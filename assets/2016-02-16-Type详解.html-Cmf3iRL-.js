import{_ as s}from"./reflect_interface-DhCJLQ1c.js";import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as n,d as l}from"./app-DT7svUeb.js";const p={},o=l('<p>本文主要介绍java中<code>Type</code>接口的来历以及相关的几个接口。<br> 通过这边文章，我们可以了解到与范型相关的几个接口, 对范型的分类有个了解;<br> 还可以了解到<code>Type</code>接口与<code>Class</code>类的关系, 以及<code>Type</code>出现的原因.</p><hr><h2 id="反射相关接口" tabindex="-1"><a class="header-anchor" href="#反射相关接口"><span>反射相关接口</span></a></h2><figure><img src="'+s+`" alt="反射相关接口继承关系图" tabindex="0" loading="lazy"><figcaption>反射相关接口继承关系图</figcaption></figure><p>下面就把<code>Type</code>的来龙去脉彻底弄清楚</p><h2 id="type" tabindex="-1"><a class="header-anchor" href="#type"><span>Type</span></a></h2><p><code>Type</code>是所有类型的父接口, 如原始类型(raw types,对应Class)、 参数化类型(parameterized types, 对应ParameterizedType)、 数组类型(array types,对应GenericArrayType)、 类型变量(type variables, 对应TypeVariable)和基本(原生)类型(primitive types, 对应Class), 子接口有<code>ParameterizedType, TypeVariable&lt;D&gt;, GenericArrayType, WildcardType</code>, 实现类有<code>Class</code></p><h2 id="parameterizedtype" tabindex="-1"><a class="header-anchor" href="#parameterizedtype"><span>ParameterizedType</span></a></h2><p>具体的范型类型, 如<code>Map&lt;String, String&gt;</code><br> 有如下方法:</p><ol><li><code>Type getRawType()</code>: 返回承载该泛型信息的对象, 如上面那个<code>Map&lt;String, String&gt;</code>承载范型信息的对象是<code>Map</code></li><li><code>Type[] getActualTypeArguments()</code>: 返回实际泛型类型列表, 如上面那个<code>Map&lt;String, String&gt;</code>实际范型列表中有两个元素, 都是<code>String</code></li><li><code>Type getOwnerType()</code>: 返回是谁的member.(上面那两个最常用)</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> TestType</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; map;</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Field f </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> TestType.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;map&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(f.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">());                               </span><span style="color:#6A737D;">// java.util.Map&lt;java.lang.String, java.lang.String&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(f.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> ParameterizedType);  </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#E1E4E8;">        ParameterizedType pType </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (ParameterizedType) f.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(pType.</span><span style="color:#B392F0;">getRawType</span><span style="color:#E1E4E8;">());                               </span><span style="color:#6A737D;">// interface java.util.Map</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (Type type </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> pType.</span><span style="color:#B392F0;">getActualTypeArguments</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(type);                                         </span><span style="color:#6A737D;">// 打印两遍: class java.lang.String</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(pType.</span><span style="color:#B392F0;">getOwnerType</span><span style="color:#E1E4E8;">());                             </span><span style="color:#6A737D;">// null</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="typevariable" tabindex="-1"><a class="header-anchor" href="#typevariable"><span>TypeVariable</span></a></h2><p>类型变量, 范型信息在编译时会被转换为一个特定的类型, 而<code>TypeVariable</code>就是用来反映在JVM编译该泛型前的信息.<br> 它的声明是这样的: <code>public interface TypeVariable&lt;D extends GenericDeclaration&gt; extends Type</code><br> 也就是说它跟<code>GenericDeclaration</code>有一定的联系, 我是这么理解的:<br><code>TypeVariable</code>是指在<code>GenericDeclaration</code>中声明的<code>&lt;T&gt;、&lt;C extends Collection&gt;</code>这些东西中的那个变量<code>T、C</code>; 它有如下方法:</p><ol><li><code>Type[] getBounds()</code>: 获取类型变量的上边界, 若未明确声明上边界则默认为<code>Object</code></li><li><code>D getGenericDeclaration()</code>: 获取声明该类型变量实体</li><li><code>String getName()</code>: 获取在源码中定义时的名字</li></ol><p>注意:</p><ul><li>类型变量在定义的时候只能使用<code>extends</code>进行(多)边界限定, 不能用<code>super</code>;</li><li>为什么边界是一个数组? 因为类型变量可以通过<code>&amp;</code>进行多个上边界限定，因此上边界有多个</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> TestType</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#F97583;">K</span><span style="color:#F97583;"> extends</span><span style="color:#F97583;"> Comparable</span><span style="color:#E1E4E8;"> &amp; </span><span style="color:#F97583;">Serializable</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    K key;</span></span>
<span class="line"><span style="color:#E1E4E8;">    V value;</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#6A737D;">        // 获取字段的类型</span></span>
<span class="line"><span style="color:#E1E4E8;">        Field fk </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> TestType.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;key&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Field fv </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> TestType.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assert.</span><span style="color:#B392F0;">that</span><span style="color:#E1E4E8;">(fk.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> TypeVariable, </span><span style="color:#9ECBFF;">&quot;必须为TypeVariable类型&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assert.</span><span style="color:#B392F0;">that</span><span style="color:#E1E4E8;">(fv.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> TypeVariable, </span><span style="color:#9ECBFF;">&quot;必须为TypeVariable类型&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        TypeVariable keyType </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (TypeVariable)fk.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        TypeVariable valueType </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (TypeVariable)fv.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">        // getName 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(keyType.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());                 </span><span style="color:#6A737D;">// K</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(valueType.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());               </span><span style="color:#6A737D;">// V</span></span>
<span class="line"><span style="color:#6A737D;">        // getGenericDeclaration 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(keyType.</span><span style="color:#B392F0;">getGenericDeclaration</span><span style="color:#E1E4E8;">());   </span><span style="color:#6A737D;">// class com.test.TestType</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(valueType.</span><span style="color:#B392F0;">getGenericDeclaration</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// class com.test.TestType</span></span>
<span class="line"><span style="color:#6A737D;">        // getBounds 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;K 的上界:&quot;</span><span style="color:#E1E4E8;">);                        </span><span style="color:#6A737D;">// 有两个</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (Type type </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> keyType.</span><span style="color:#B392F0;">getBounds</span><span style="color:#E1E4E8;">()) {                </span><span style="color:#6A737D;">// interface java.lang.Comparable</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(type);                          </span><span style="color:#6A737D;">// interface java.io.Serializable</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;V 的上界:&quot;</span><span style="color:#E1E4E8;">);                        </span><span style="color:#6A737D;">// 没明确声明上界的, 默认上界是 Object</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (Type type </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> valueType.</span><span style="color:#B392F0;">getBounds</span><span style="color:#E1E4E8;">()) {              </span><span style="color:#6A737D;">// class java.lang.Object</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(type);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="genericarraytype" tabindex="-1"><a class="header-anchor" href="#genericarraytype"><span>GenericArrayType</span></a></h2><p>范型数组,组成数组的元素中有范型则实现了该接口; 它的组成元素是<code>ParameterizedType</code>或<code>TypeVariable</code>类型,它只有一个方法:</p><ol><li><code>Type getGenericComponentType()</code>: 返回数组的组成对象, 即被JVM编译后实际的对象</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> TestType</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Method method </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Test.class.</span><span style="color:#B392F0;">getDeclaredMethods</span><span style="color:#E1E4E8;">()[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#6A737D;">        // public void com.test.Test.show(java.util.List[],java.lang.Object[],java.util.List,java.lang.String[],int[])</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(method);</span></span>
<span class="line"><span style="color:#F97583;">        Type</span><span style="color:#E1E4E8;">[] types </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">getGenericParameterTypes</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 这是 Method 中的方法</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (Type type </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> types) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(type </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> GenericArrayType);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#B392F0;"> Test</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> show</span><span style="color:#E1E4E8;">(List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt;[] </span><span style="color:#FFAB70;">pTypeArray</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">vTypeArray</span><span style="color:#E1E4E8;">, List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">list</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">strings</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">ints</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一个参数<code>List&lt;String&gt;[]</code>的组成元素<code>List&lt;String&gt;</code>是<code>ParameterizedType</code>类型, 打印结果为<code>true</code></li><li>第二个参数<code>T[]</code>的组成元素<code>T</code>是<code>TypeVariable</code>类型, 打印结果为<code>true</code></li><li>第三个参数<code>List&lt;String&gt;</code>不是数组, 打印结果为<code>false</code></li><li>第四个参数<code>String[]</code>的组成元素<code>String</code>是普通对象, 没有范型, 打印结果为<code>false</code></li><li>第五个参数<code>int[] pTypeArray</code>的组成元素<code>int</code>是原生类型, 也没有范型, 打印结果为<code>false</code></li></ul><h2 id="wildcardtype" tabindex="-1"><a class="header-anchor" href="#wildcardtype"><span>WildcardType</span></a></h2><p>该接口表示通配符泛型, 比如<code>? extends Number</code> 和 <code>? super Integer</code> 它有如下方法:</p><ol><li><code>Type[] getUpperBounds()</code>: 获取范型变量的上界</li><li><code>Type[] getLowerBounds()</code>: 获取范型变量的下界</li></ol><p>注意:</p><ul><li>现阶段通配符只接受一个上边界或下边界, 返回数组是为了以后的扩展, 实际上现在返回的数组的大小是1</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> TestType</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">?</span><span style="color:#F97583;"> extends</span><span style="color:#F97583;"> Number</span><span style="color:#E1E4E8;">&gt; a;  </span><span style="color:#6A737D;">// // a没有下界, 取下界会抛出ArrayIndexOutOfBoundsException</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">?</span><span style="color:#F97583;"> super</span><span style="color:#F97583;"> String</span><span style="color:#E1E4E8;">&gt; b;</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Field fieldA </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> TestType.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Field fieldB </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> TestType.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">        // 先拿到范型类型</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assert.</span><span style="color:#B392F0;">that</span><span style="color:#E1E4E8;">(fieldA.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> ParameterizedType, </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assert.</span><span style="color:#B392F0;">that</span><span style="color:#E1E4E8;">(fieldB.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> ParameterizedType, </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        ParameterizedType pTypeA </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (ParameterizedType) fieldA.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        ParameterizedType pTypeB </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (ParameterizedType) fieldB.</span><span style="color:#B392F0;">getGenericType</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">        // 再从范型里拿到通配符类型</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assert.</span><span style="color:#B392F0;">that</span><span style="color:#E1E4E8;">(pTypeA.</span><span style="color:#B392F0;">getActualTypeArguments</span><span style="color:#E1E4E8;">()[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> WildcardType, </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assert.</span><span style="color:#B392F0;">that</span><span style="color:#E1E4E8;">(pTypeB.</span><span style="color:#B392F0;">getActualTypeArguments</span><span style="color:#E1E4E8;">()[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> WildcardType, </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        WildcardType wTypeA </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (WildcardType) pTypeA.</span><span style="color:#B392F0;">getActualTypeArguments</span><span style="color:#E1E4E8;">()[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        WildcardType wTypeB </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (WildcardType) pTypeB.</span><span style="color:#B392F0;">getActualTypeArguments</span><span style="color:#E1E4E8;">()[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#6A737D;">        // 方法测试</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(wTypeA.</span><span style="color:#B392F0;">getUpperBounds</span><span style="color:#E1E4E8;">()[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);   </span><span style="color:#6A737D;">// class java.lang.Number</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(wTypeB.</span><span style="color:#B392F0;">getLowerBounds</span><span style="color:#E1E4E8;">()[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);   </span><span style="color:#6A737D;">// class java.lang.String</span></span>
<span class="line"><span style="color:#6A737D;">        // 看看通配符类型到底是什么, 打印结果为: ? extends java.lang.Number</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(wTypeA);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再写几个边界的例子:</p><ul><li><code>List&lt;? extends Number&gt;</code>, 上界为<code>class java.lang.Number</code>, 属于<code>Class</code>类型</li><li><code>List&lt;? extends List&lt;T&gt;&gt;</code>, 上界为<code>java.util.List&lt;T&gt;</code>, 属于<code>ParameterizedType</code>类型</li><li><code>List&lt;? extends List&lt;String&gt;&gt;</code>, 上界为<code>java.util.List&lt;java.lang.String&gt;</code>, 属于<code>ParameterizedType</code>类型</li><li><code>List&lt;? extends T&gt;</code>, 上界为<code>T</code>, 属于<code>TypeVariable</code>类型</li><li><code>List&lt;? extends T[]&gt;</code>, 上界为<code>T[]</code>, 属于<code>GenericArrayType</code>类型</li></ul><p>它们最终统一成Type作为数组的元素类型</p><h2 id="type及其子接口的来历" tabindex="-1"><a class="header-anchor" href="#type及其子接口的来历"><span>Type及其子接口的来历</span></a></h2><h3 id="泛型出现之前的类型" tabindex="-1"><a class="header-anchor" href="#泛型出现之前的类型"><span>泛型出现之前的类型</span></a></h3><p>没有泛型的时候，只有原始类型。此时，所有的原始类型都通过字节码文件类Class类进行抽象。Class类的一个具体对象就代表一个指定的原始类型。</p><h3 id="泛型出现之后的类型" tabindex="-1"><a class="header-anchor" href="#泛型出现之后的类型"><span>泛型出现之后的类型</span></a></h3><p>泛型出现之后，扩充了数据类型。从只有原始类型扩充了参数化类型、类型变量类型、限定符类型 、泛型数组类型。</p><h3 id="与泛型有关的类型不能和原始类型统一到class的原因" tabindex="-1"><a class="header-anchor" href="#与泛型有关的类型不能和原始类型统一到class的原因"><span>与泛型有关的类型不能和原始类型统一到Class的原因</span></a></h3><ul><li>产生泛型擦除的原因</li></ul><p>原始类型和新产生的类型都应该统一成各自的字节码文件类型对象。但是由于泛型不是最初Java中的成分。如果真的加入了泛型，涉及到JVM指令集的修改，这是非常致命的。</p><ul><li>Java中如何引入泛型</li></ul><p>为了使用泛型又不真正引入泛型，Java采用泛型擦除机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部擦除。</p><ul><li>Class不能表达与泛型有关的类型</li></ul><p>因此，与泛型有关的参数化类型、类型变量类型、限定符类型 、泛型数组类型这些类型编译后全部被打回原形，在字节码文件中全部都是泛型被擦除后的原始类型，并不存在和自身类型对应的字节码文件。所以和泛型相关的新扩充进来的类型不能被统一到Class类中。</p><ul><li>与泛型有关的类型在Java中的表示</li></ul><p>为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了<code>ParameterizedType, TypeVariable&lt;D&gt;, GenericArrayType, WildcardType</code>几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。</p><ul><li>引入Type的原因</li></ul><p>为了程序的扩展性，最终引入了Type接口作为<code>Class和ParameterizedType, TypeVariable&lt;D&gt;, GenericArrayType, WildcardType</code>这几种类型的总的父接口。这样可以用Type类型的参数来接受以上五种子类的实参或者返回值类型就是Type类型的参数。统一了与泛型有关的类型和原始类型Class</p><ul><li>Type接口中没有方法的原因</li></ul><p>从上面看到，Type的出现仅仅起到了通过多态来达到程序扩展性提高的作用，没有其他的作用。因此Type接口的源码中没有任何方法。</p>`,49),t=[o];function c(r,i){return n(),e("div",null,t)}const u=a(p,[["render",c],["__file","2016-02-16-Type详解.html.vue"]]),v=JSON.parse('{"path":"/program/backend/2016-02-16-Type%E8%AF%A6%E8%A7%A3.html","title":"Java中的Type详解","lang":"zh-CN","frontmatter":{"title":"Java中的Type详解","date":"2016-02-16T00:00:00.000Z","category":"Java","tag":["反射"],"order":-20160216,"description":"本文主要介绍java中Type接口的来历以及相关的几个接口。 通过这边文章，我们可以了解到与范型相关的几个接口, 对范型的分类有个了解; 还可以了解到Type接口与Class类的关系, 以及Type出现的原因. 反射相关接口 反射相关接口继承关系图反射相关接口继承关系图 下面就把Type的来龙去脉彻底弄清楚 Type Type是所有类型的父接口, 如原...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/backend/2016-02-16-Type%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"Java中的Type详解"}],["meta",{"property":"og:description","content":"本文主要介绍java中Type接口的来历以及相关的几个接口。 通过这边文章，我们可以了解到与范型相关的几个接口, 对范型的分类有个了解; 还可以了解到Type接口与Class类的关系, 以及Type出现的原因. 反射相关接口 反射相关接口继承关系图反射相关接口继承关系图 下面就把Type的来龙去脉彻底弄清楚 Type Type是所有类型的父接口, 如原..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-30T10:23:03.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"反射"}],["meta",{"property":"article:published_time","content":"2016-02-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-30T10:23:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java中的Type详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-02-16T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-30T10:23:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"反射相关接口","slug":"反射相关接口","link":"#反射相关接口","children":[]},{"level":2,"title":"Type","slug":"type","link":"#type","children":[]},{"level":2,"title":"ParameterizedType","slug":"parameterizedtype","link":"#parameterizedtype","children":[]},{"level":2,"title":"TypeVariable","slug":"typevariable","link":"#typevariable","children":[]},{"level":2,"title":"GenericArrayType","slug":"genericarraytype","link":"#genericarraytype","children":[]},{"level":2,"title":"WildcardType","slug":"wildcardtype","link":"#wildcardtype","children":[]},{"level":2,"title":"Type及其子接口的来历","slug":"type及其子接口的来历","link":"#type及其子接口的来历","children":[{"level":3,"title":"泛型出现之前的类型","slug":"泛型出现之前的类型","link":"#泛型出现之前的类型","children":[]},{"level":3,"title":"泛型出现之后的类型","slug":"泛型出现之后的类型","link":"#泛型出现之后的类型","children":[]},{"level":3,"title":"与泛型有关的类型不能和原始类型统一到Class的原因","slug":"与泛型有关的类型不能和原始类型统一到class的原因","link":"#与泛型有关的类型不能和原始类型统一到class的原因","children":[]}]}],"git":{"createdTime":1719158757000,"updatedTime":1719742983000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":2}]},"filePathRelative":"program/backend/2016-02-16-Type详解.md","localizedDate":"2016年2月16日","excerpt":"","autoDesc":true}');export{u as comp,v as data};
