import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as n,d as e}from"./app-DQnd5bNn.js";const l={},t=e(`<h2 id="如何创建一个线程" tabindex="-1"><a class="header-anchor" href="#如何创建一个线程"><span>如何创建一个线程</span></a></h2><p>按 Java 语言规范中的说法，创建线程只有一种方式，就是创建一个 Thread 对象。而从 HotSpot 虚拟机的角度看，创建一个虚拟机线程 有两种方式，一种是创建 Thread 对象，另一种是创建 一个本地线程，加入到虚拟机线程中。</p><p>如果从 Java 语法的角度。有两种方法。</p><p>第一是继承 Thread 类，实现 run 方法，并创建子类对象。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">	public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> startThreadUseSubClass</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">		class</span><span style="color:#B392F0;"> MyThread</span><span style="color:#F97583;"> extends</span><span style="color:#B392F0;"> Thread</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">			public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">				System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;start thread using Subclass of Thread&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">			}</span></span>
<span class="line"><span style="color:#E1E4E8;">		}</span></span>
<span class="line"><span style="color:#E1E4E8;">		MyThread thread </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> MyThread</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">		thread.</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另一种是传递给 Thread 构造函数一个 Runnable 对象。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">	public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> startThreadUseRunnalbe</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">		Thread thread </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Thread</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Runnable</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">			public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">				System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;start thread using runnable&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">			}</span></span>
<span class="line"><span style="color:#E1E4E8;">		});</span></span>
<span class="line"><span style="color:#E1E4E8;">		thread.</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然， Runnalbe 对象，也不是只有这一种形式，例如如果我们想要线程执行时返回一个值，就需要用到另一种 Runnalbe 对象，它 对原来的 Runnalbe 对象进行了包装。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">	public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> startFutureTask</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">		FutureTask&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; task </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#E1E4E8;"> FutureTask&lt;&gt;(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Callable&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#F97583;">			public</span><span style="color:#E1E4E8;"> Integer </span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">				return</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">			}</span></span>
<span class="line"><span style="color:#E1E4E8;">		});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">		new</span><span style="color:#B392F0;"> Thread</span><span style="color:#E1E4E8;">(task).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">		try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">			Integer result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> task.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">			System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;future result &quot;</span><span style="color:#F97583;"> +</span><span style="color:#E1E4E8;"> result);</span></span>
<span class="line"><span style="color:#E1E4E8;">		} </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">			e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">		} </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (ExecutionException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">			e.</span><span style="color:#B392F0;">printStackTrace</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">		}</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="结束线程" tabindex="-1"><a class="header-anchor" href="#结束线程"><span>结束线程</span></a></h2><h2 id="wait-与-sleep" tabindex="-1"><a class="header-anchor" href="#wait-与-sleep"><span>wait 与 sleep</span></a></h2><p>sleep 会使得当前线程休眠一段时间，但并不会释放已经得到的锁。</p><p>wait 会阻塞住，并释放已经得到的锁。一直到有人调用 notify 或者 notifyAll，它会重新尝试得到锁，然后再唤醒。</p><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h2><h3 id="好处" tabindex="-1"><a class="header-anchor" href="#好处"><span>好处</span></a></h3><ul><li>复用</li></ul><p>线程池中有一系列线程，这些线程在执行完任务后，并不会被销毁，而会从任务队列中取出任务，执行这些任务。这样，就避免为每个任务 都创建线程，销毁线程。 在有大量短命线程的场景下，如果创建线程和销毁线程的时间比线程执行任务的时间还长，显然是不划算的，这时候，使用线程池就会有明显 的好处。</p><ul><li>流控</li></ul><p>同时，可以设置线程数目，这样，线程不会增大到影响系统整体性能的程度。当任务太多时，可以在队列中排队， 如果有空闲线程，他们会从队列中取出任务执行。</p><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><ul><li>线程数目</li></ul><p>那么，线程的数目要设置成多少呢？这需要根据任务类型的不同来设置，假如是大量计算型的任务，他们不会阻塞，那么可以将线程数目设置 为处理器数目。而如果任务中涉及大量IO，有些线程会阻塞住，这样就要根据阻塞线程数目与运行线程数目的比例，以及处理器数目来设置 线程总数目。例如阻塞线程数目与运行线程数目之比为n, 处理器数目为p，那么可以设置 n * (p + 1) 个线程，保证有 n 个线程处于运行 状态。</p><ul><li>Executors</li></ul><p>JDK 的 java.util.concurrent.Executors 类提供了几个静态的方法，用于创建不同类型的线程池。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">ExecutorService service </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newFixedThreadPool</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">ArrayList&lt;Future&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;&gt; results </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> 14</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	Future&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> service.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Callable&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#F97583;">		public</span><span style="color:#E1E4E8;"> Integer </span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">		return</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Random</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">nextInt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">	});</span></span>
<span class="line"><span style="color:#E1E4E8;">	results.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">r</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>newFixedThreadPool</code> 可以创建固定数目的线程，一旦创建不会自动销毁线程，即便长期没有任务。除非显式关闭线程池。如果任务队列中有任务，就取出任务执行。</p><p>另外，还可以使用 <code>newCachedThreadPool</code> 方法创建一个不设定固定线程数目的线程池，它有一个特性，线程完成任务后，如果一分钟之内又有新任务，就会复用这个线程执行新任务。如果超过一分钟还没有任务执行，就会自动销毁。</p><p>另外，还提供了 <code>newSingleThreadExecutor</code> 创建有一个工作线程的线程池。</p><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><p>JDK 中的线程池通过 HashSet 存储工作者线程，通过 BlockingQueue 来存储待处理任务。</p><p>通过核心工作者数目(corePoolSize) 和 最大工作者数目(maximumPoolSize) 来确定如何处理任务。如果当前工作者线程数目 小于核心工作者数目，则创建一个工作者线程执行这个任务。否则，将这个任务放入待处理队列。如果入队失败，再看看当前工作 者数目是不是小于最大工作者数目，如果小于，则创建工作者线程执行这个任务。否则，拒绝执行这个任务。</p><p>另外，如果待处理队列中没有任务要处理，并且工作者线程数目超过了核心工作者数目，那么，需要减少工作者线程数目。</p>`,32),p=[t];function o(r,c){return a(),n("div",null,p)}const d=s(l,[["render",o],["__file","2015-01-05-java中的并发.html.vue"]]),y=JSON.parse('{"path":"/program/java/2015-01-05-java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91.html","title":"java中的并发","lang":"zh-CN","frontmatter":{"title":"java中的并发","date":"2015-01-05T00:00:00.000Z","category":"Java","tag":"Java","order":-20150105,"description":"如何创建一个线程 按 Java 语言规范中的说法，创建线程只有一种方式，就是创建一个 Thread 对象。而从 HotSpot 虚拟机的角度看，创建一个虚拟机线程 有两种方式，一种是创建 Thread 对象，另一种是创建 一个本地线程，加入到虚拟机线程中。 如果从 Java 语法的角度。有两种方法。 第一是继承 Thread 类，实现 run 方法，并...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/java/2015-01-05-java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"java中的并发"}],["meta",{"property":"og:description","content":"如何创建一个线程 按 Java 语言规范中的说法，创建线程只有一种方式，就是创建一个 Thread 对象。而从 HotSpot 虚拟机的角度看，创建一个虚拟机线程 有两种方式，一种是创建 Thread 对象，另一种是创建 一个本地线程，加入到虚拟机线程中。 如果从 Java 语法的角度。有两种方法。 第一是继承 Thread 类，实现 run 方法，并..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-09T09:40:25.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2015-01-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-09T09:40:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java中的并发\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2015-01-05T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-09T09:40:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"如何创建一个线程","slug":"如何创建一个线程","link":"#如何创建一个线程","children":[]},{"level":2,"title":"结束线程","slug":"结束线程","link":"#结束线程","children":[]},{"level":2,"title":"wait 与 sleep","slug":"wait-与-sleep","link":"#wait-与-sleep","children":[]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[{"level":3,"title":"好处","slug":"好处","link":"#好处","children":[]},{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]}]}],"git":{"createdTime":1719153683000,"updatedTime":1725874825000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/java/2015-01-05-java中的并发.md","localizedDate":"2015年1月5日","excerpt":"","autoDesc":true}');export{d as comp,y as data};
