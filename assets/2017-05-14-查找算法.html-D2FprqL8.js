import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o,c as l,d as s}from"./app-DJRQkAjL.js";const c="/assets/BTree-CDW1tjyv.png",n="/assets/BTreeNode-TwgdNb5K.png",a="/assets/B_Tree-BMLQV_zY.png",d={},i=s(`<h2 id="折半查找" tabindex="-1"><a class="header-anchor" href="#折半查找"><span>折半查找</span></a></h2><p><code>折半查找</code>也叫<code>二分查找</code>, 前提是顺序表 <strong>有序</strong></p><ul><li>基本思想: <ol><li>将给定值<code>key</code>与中间元素比较, 若相等, 查找成功, 返回元素位置; 若不等, 根据大小查找左半部分或右半部分</li><li>缩小范围, 在左边或右边进行同样的查找, 直到找到为止</li><li>若最后都没找到, 查找失败</li></ol></li><li>算法描述:</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // 折半查找</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> int</span><span style="color:#B392F0;"> binarySearch</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> key) {</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> low </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> high </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A.length </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (low </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> high) {</span></span>
<span class="line"><span style="color:#F97583;">            int</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (low </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> high) </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 中间位置</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (key </span><span style="color:#F97583;">==</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[mid]) {         </span><span style="color:#6A737D;">// 查找成功则返回所在位置</span></span>
<span class="line"><span style="color:#F97583;">                return</span><span style="color:#E1E4E8;"> mid;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#F97583;"> if</span><span style="color:#E1E4E8;"> (key </span><span style="color:#F97583;">&lt;</span><span style="color:#F97583;"> A</span><span style="color:#E1E4E8;">[mid]) {   </span><span style="color:#6A737D;">// 查找前半部分</span></span>
<span class="line"><span style="color:#E1E4E8;">                high </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {                     </span><span style="color:#6A737D;">// 查找右半部分</span></span>
<span class="line"><span style="color:#E1E4E8;">                low </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#F97583;"> -</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 查找失败</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>时间复杂度: <code>O(logn)</code>(<code>log</code>表示以2为底的对数)</li><li>适用场景: 必须有序</li></ul><h2 id="b树" tabindex="-1"><a class="header-anchor" href="#b树"><span>B树</span></a></h2><ul><li>注意: 下面<code>[m/2]</code>意思为向上取整</li></ul><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><p><code>B树</code>又称<code>多路平衡查找树</code>或<code>多路平衡查找树</code>, 但一般把<code>二叉平衡排序树</code>成为<code>B树</code>, 把</p><ul><li>多路: 几叉就是几路, 即一个结点最多有几个子结点</li><li>平衡树: 左右子树高度差不超过1(以二叉平衡树为例说明)</li><li>查找树: <code>排序树</code>也叫<code>查找树</code>, 以二叉平衡树为例说明, 左子树结点都小于根, 右子树结点都大于根</li><li>一个<code>m</code>阶的<code>B树</code>最多有<code>m</code>棵子树, 如下图为3阶B树示例:</li></ul><figure><img src="`+c+'" alt="BTree" tabindex="0" loading="lazy"><figcaption>BTree</figcaption></figure><ul><li><code>m</code>阶的<code>B树</code>的每个结点最多包含<code>m-1</code>个关键字, <code>m</code>棵子树. 结点的结构类似于下图:</li></ul><figure><img src="'+n+'" alt="BTreeNode结构图" tabindex="0" loading="lazy"><figcaption>BTreeNode结构图</figcaption></figure><ul><li>关键字之间有一定关系:<code>K1&lt;K2&lt;...&lt;Kn</code>, <code>P(i-1)</code>子树的关键字都小于<code>Ki</code>, <code>P(i)</code>子树的关键字都大于<code>Ki</code></li><li>根结点最少有1个关键字, 2棵子树</li><li>除根结点外的结点最少有<code>[m/2]</code>棵子树, <code>[m/2] -1</code>个关键字(插入时分裂是从中间分裂的)</li></ul><h3 id="b树的查找" tabindex="-1"><a class="header-anchor" href="#b树的查找"><span>B树的查找</span></a></h3><p><code>B树</code>一般是保存在磁盘上的, <code>B树</code>的查找跟二叉树的查找很像, 只不过每个结点变成了一个多关键字的有序表.<br><code>B树</code>的查找分个基本操作:</p><ol><li>在<code>B树</code>中找结点, 把找到的<code>结点</code>从磁盘读入内存</li><li>在<code>结点</code>内找关键字, 这个操作在内存中进行, 相当于在一个有序表中查找关键字K, 可以使用顺序查找或二分查找</li></ol><p>若在结点上找到与关键字K则查找成功, 否则按照对应的指针去下一个结点中找, 当指针为空还没找到, 则查找失败</p><h3 id="b树的插入" tabindex="-1"><a class="header-anchor" href="#b树的插入"><span>B树的插入</span></a></h3><p><code>B树</code>的插入操作比二叉查找树要复杂, 并不能简单的找到终端结点然后添加到进去, 因为有可能插入结点后就不再满足<code>B树</code>的定义要求了.<br> 把关键字<code>key</code>插入到<code>B树</code>的过程如下:</p><ol><li>定位: 利用上面的B树查找算法, 找到该关键字该插入到的最底层的那个结点.</li><li>插入: 由于每个结点的关键字个数最多为<code>m-1</code>, 所以若插入后关键字个数小于<code>m</code>则可以直接插入, 若等于<code>m</code>则必须对结点进行<code>分裂</code>.</li></ol><ul><li><code>分裂</code>的方法:</li></ul><ol><li>取一个新结点, 将插入<code>key</code>后的原结点从中间位置(<code>[m/2]</code>)分成两部分</li><li>左半部分(不包括中间位置)仍留在原结点, 右半部分(不包括中间位置)放到新结点中</li><li>中间位置(<code>[m/2]</code>)的关键字插入到原结点的父结点中.</li><li>若父结点关键字个数没超过上限, 则新结点挂在这个中间结点的后面; 若父结点关键字个数超过了上限, 对父结点也进行这样的分裂, 直至传到根结点, 这样将导致<code>B树</code>的高度增1.</li></ol><h3 id="b树的删除" tabindex="-1"><a class="header-anchor" href="#b树的删除"><span>B树的删除</span></a></h3><p><code>B树</code>的删除与插入类似, 但更复杂一些, 要涉及结点的<code>合并</code>.</p><p>当要删除的关键字<code>k</code>不在终端结点时:</p><ul><li>若<code>k的左边子树</code>(<code>k</code>与<code>k-1</code>之间的子树)关键字个数n有<code>n &gt;= [m/2] -1</code>, 则找出<code>k</code>的前驱值<code>k&#39;</code>(<code>k的左边子树</code>中最大的那个), 用<code>k&#39;</code>取代<code>k</code>, 再递归地删除<code>k&#39;</code>. 最终会传递下去转变成在终端结点的情况.</li><li>若<code>k的右边子树</code>(<code>k</code>与<code>k+1</code>之间的子树)关键字个数n有<code>n &gt;= [m/2] -1</code>, 则找出<code>k</code>的后继值<code>k&#39;</code>(<code>k的右边子树</code>中最小的那个), 用<code>k&#39;</code>取代<code>k</code>, 再递归地删除<code>k&#39;</code>. 最终会传递下去转变成在终端结点的情况.</li><li>若前后两个子树关键字个数均为<code>[m/2] -1</code>, 则把左右两个子树合并成一个子树(这样合并后仍不会超过<code>m-1</code>), 直接删除<code>k</code>即可</li></ul><p>当要删除的关键字<code>k</code>在终端结点时:</p><ul><li>直接删除关键字的情况: 若该结点关键字个数n有<code>n &gt; [m/2] -1</code>, 则直接删除关键字<code>k</code>, 写入磁盘</li><li>兄弟够借: 若该结点关键字个数n有<code>n = [m/2] -1</code>, 但相邻的右兄弟结点关键字<code>n &gt; [m/2] -1</code>, 此时为兄弟够借的情况; 这时调整左兄弟, 右兄弟, 父结点, 具体做法是右兄弟的最小值调整到到父结点(左右兄弟中间那个值), 父结点那个关键字调整到到左兄弟</li><li>兄弟不够借: 若该结点关键字个数n有<code>n = [m/2] -1</code>, 但相邻的右兄弟结点关键字<code>n = [m/2] -1</code>, 此时为兄弟不够借的情况; 这时删除关键字<code>k</code>后, 把左兄弟, 父结点, 右兄弟的关键字进行合并</li></ul><h2 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树"><span>B+树</span></a></h2><p><code>B+树</code>广泛应用于数据库存储引擎</p><h3 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1"><span>基本概念</span></a></h3><p>一棵<code>m</code>阶的<code>B+树</code>需满足下列条件:</p><ol><li>每个分支最多有<code>m</code>棵子树</li><li>根结点最少有两颗子树, 其他结点最少有<code>[m/2]</code>棵子树(<code>[]</code>表示向上取整)</li><li>结点的子树个数与关键字个数相等</li><li>所有的叶子结点包含全部关键字(即所有的叶子结点就是全部数据的集合), 而且叶子结点中将关键字按大小排序, 并且相邻叶结点按大小顺序连接起来</li><li>所有的分支结点(非叶子结点)中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针.</li></ol><ul><li>一个<code>B+树</code>的例子:</li></ul><figure><img src="'+a+'" alt="B+Tree" tabindex="0" loading="lazy"><figcaption>B+Tree</figcaption></figure><h3 id="b-树与b树的区别" tabindex="-1"><a class="header-anchor" href="#b-树与b树的区别"><span>B+树与B树的区别</span></a></h3><ol><li><code>B+树</code>中一个结点有<code>n</code>个关键字就有<code>n</code>棵子树, 即每个关键字对应一颗子树; <code>B树</code>中有<code>n</code>个关键字的节点含有<code>n+1</code>棵子树</li><li><code>B+树</code>中非根结点关键字的个数<code>n</code>范围是<code>[m/2] &lt;= n &lt;= m</code>; <code>B树</code>中为<code>[m/2]-1 &lt;= n &lt;= m</code></li><li><code>B+树</code>中的非叶子节点仅起到索引的作用, 不包含关键字对应记录的存储地址; <code>B树</code>中是有存储数据的</li><li><code>B+树</code>中叶子节点包含全部关键字; <code>B树</code>中叶子结点包含的关键字和其他结点是不重复的, 所有结点加起来才是全部关键字</li></ol>',38),t=[i];function p(r,y){return o(),l("div",null,t)}const h=e(d,[["render",p],["__file","2017-05-14-查找算法.html.vue"]]),u=JSON.parse('{"path":"/algorithm/2017-05-14-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html","title":"查找算法","lang":"zh-CN","frontmatter":{"title":"查找算法","date":"2017-05-14T00:00:00.000Z","category":"Algorithm","tag":["算法"],"order":-20170514,"description":"折半查找 折半查找也叫二分查找, 前提是顺序表 有序 基本思想: 将给定值key与中间元素比较, 若相等, 查找成功, 返回元素位置; 若不等, 根据大小查找左半部分或右半部分 缩小范围, 在左边或右边进行同样的查找, 直到找到为止 若最后都没找到, 查找失败 算法描述: 时间复杂度: O(logn)(log表示以2为底的对数) 适用场景: 必须有序 ...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/algorithm/2017-05-14-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"查找算法"}],["meta",{"property":"og:description","content":"折半查找 折半查找也叫二分查找, 前提是顺序表 有序 基本思想: 将给定值key与中间元素比较, 若相等, 查找成功, 返回元素位置; 若不等, 根据大小查找左半部分或右半部分 缩小范围, 在左边或右边进行同样的查找, 直到找到为止 若最后都没找到, 查找失败 算法描述: 时间复杂度: O(logn)(log表示以2为底的对数) 适用场景: 必须有序 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-25T00:38:47.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2017-05-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-25T00:38:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"查找算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2017-05-14T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-25T00:38:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"折半查找","slug":"折半查找","link":"#折半查找","children":[]},{"level":2,"title":"B树","slug":"b树","link":"#b树","children":[{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"B树的查找","slug":"b树的查找","link":"#b树的查找","children":[]},{"level":3,"title":"B树的插入","slug":"b树的插入","link":"#b树的插入","children":[]},{"level":3,"title":"B树的删除","slug":"b树的删除","link":"#b树的删除","children":[]}]},{"level":2,"title":"B+树","slug":"b-树","link":"#b-树","children":[{"level":3,"title":"基本概念","slug":"基本概念-1","link":"#基本概念-1","children":[]},{"level":3,"title":"B+树与B树的区别","slug":"b-树与b树的区别","link":"#b-树与b树的区别","children":[]}]}],"git":{"createdTime":1719160919000,"updatedTime":1719275927000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":3}]},"filePathRelative":"algorithm/2017-05-14-查找算法.md","localizedDate":"2017年5月14日","excerpt":"","autoDesc":true}');export{h as comp,u as data};
