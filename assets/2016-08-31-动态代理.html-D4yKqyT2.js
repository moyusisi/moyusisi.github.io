import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,o as c,c as t,a as n,b as s,e as l,w as e,d as p}from"./app-J8acWEVP.js";const i={},E=n("code",null,"InvocationHandler",-1),y=p(`<h2 id="jdk动态代理使用示例" tabindex="-1"><a class="header-anchor" href="#jdk动态代理使用示例"><span>JDK动态代理使用示例</span></a></h2><p>JDK的动态代理是依赖于接口实现的,因此要先定义接口,然后在定义接口的实现类</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// Hello.java 定义接口</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> interface</span><span style="color:#B392F0;"> Hello</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    void</span><span style="color:#B392F0;"> hello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">name</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">    void</span><span style="color:#B392F0;"> sayHello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">name</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// HelloImpl.java 接口的实现类</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> HelloImpl</span><span style="color:#F97583;"> implements</span><span style="color:#B392F0;"> Hello</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> hello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">name</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#B392F0;">        sayHello</span><span style="color:#E1E4E8;">(name);   </span><span style="color:#6A737D;">// 注意这里调用了另一个方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> sayHello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">name</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Hello &quot;</span><span style="color:#F97583;"> +</span><span style="color:#E1E4E8;"> name);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> test</span><span style="color:#E1E4E8;">() {  </span><span style="color:#6A737D;">// 这个方法没有实现任何接口</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;test&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用JDK的动态代理, 还需要一个<code>InvocationHandler</code>接口的实现类</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// JDKProxy.java 定义接口</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> JDKProxy</span><span style="color:#F97583;"> implements</span><span style="color:#B392F0;"> InvocationHandler</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> Object target;  </span><span style="color:#6A737D;">// 被代理对象</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#B392F0;"> JDKProxy</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.target </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> target;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">proxy</span><span style="color:#E1E4E8;">, Method </span><span style="color:#FFAB70;">method</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;before invoke&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object obj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(target, args);</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;after invoke&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> obj;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 获取通过JDK动态代理出来的对象</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">getProxy</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> Proxy.</span><span style="color:#B392F0;">newProxyInstance</span><span style="color:#E1E4E8;">(target.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getClassLoader</span><span style="color:#E1E4E8;">(), target.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getInterfaces</span><span style="color:#E1E4E8;">(), </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后是测试类</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// JDKProxyTest.java 定义接口</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> JDKProxyTest</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        HelloImpl hello </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> HelloImpl</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        JDKProxy handler </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> JDKProxy</span><span style="color:#E1E4E8;">(hello);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Hello helloProxy </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (Hello) handler.</span><span style="color:#B392F0;">getProxy</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 无法把代理对象转换成 HelloImpl</span></span>
<span class="line"><span style="color:#6A737D;">        // 调用代理对象的方法, 打印出before和after</span></span>
<span class="line"><span style="color:#E1E4E8;">        helloProxy.</span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Tom&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">        /**</span></span>
<span class="line"><span style="color:#6A737D;">         * 只会打印一次before和after</span></span>
<span class="line"><span style="color:#6A737D;">         * 虽然hello方法中调用了sayHello方法, 但调用的是被代理对象(target)的方法, 而不是代理对象(proxy)的方法</span></span>
<span class="line"><span style="color:#6A737D;">         * 所以写AOP拦截的时候要特别注意这里</span></span>
<span class="line"><span style="color:#6A737D;">         */</span></span>
<span class="line"><span style="color:#E1E4E8;">        helloProxy.</span><span style="color:#B392F0;">hello</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Tom&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">//        proxy.test(); // proxy是无法调用test方法的, 因为接口中没有该方法, AOP拦截的时候也需要注意</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cglib动态代理" tabindex="-1"><a class="header-anchor" href="#cglib动态代理"><span>CGLib动态代理</span></a></h2><p>JDK动态代理与CGLib动态代理均是实现Spring AOP的基础, CGLib使用的是字节码增强技术, 原理是创建被代理对象的一个子类, 并在子类中采用方法拦截的技术拦截所有父类方法的调用, 所以它不依赖于接口. 跟JDK动态代理对比, 被代理对象<code>target</code>在CGLib中相当于一个<code>SuperClass</code>, 而代理对象<code>proxy</code>相当于这个<code>SuperClass</code>的一个子类.</p>`,9),d=n("code",null,"MethodInterceptor",-1),v=n("code",null,"Enhancer",-1),u=n("code",null,"MethodProxy",-1),m=n("code",null,"cglib.jar",-1),b=n("code",null,"spring-core.jar",-1),F=p(`<p>代理类可以这样写:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// CGLibProxy.java 定义接口</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> CGLibProxy</span><span style="color:#F97583;"> implements</span><span style="color:#B392F0;"> MethodInterceptor</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> Enhancer enhancer </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Enhancer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#FFAB70;"> clazz</span><span style="color:#6A737D;"> 被代理对象对应的Class</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@return</span><span style="color:#6A737D;"> 代理对象 proxy</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">getProxy</span><span style="color:#E1E4E8;">(Class </span><span style="color:#FFAB70;">clazz</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 设置需要被代理的类(被代理对象的类型)</span></span>
<span class="line"><span style="color:#E1E4E8;">        enhancer.</span><span style="color:#B392F0;">setSuperclass</span><span style="color:#E1E4E8;">(clazz);</span></span>
<span class="line"><span style="color:#E1E4E8;">        enhancer.</span><span style="color:#B392F0;">setCallback</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">        // 通过字节码技术动态创建子类实例(代理对象)</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> enhancer.</span><span style="color:#B392F0;">create</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">intercept</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">, Method </span><span style="color:#FFAB70;">method</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">, MethodProxy </span><span style="color:#FFAB70;">methodProxy</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;before&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">        //通过代理类调用父类中的方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> methodProxy.</span><span style="color:#B392F0;">invokeSuper</span><span style="color:#E1E4E8;">(target, args);</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;after&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是测试类:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// CGLibProxyTest.java 定义接口</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> CGLibProxyTest</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        CGLibProxy proxy </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> CGLibProxy</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        HelloImpl helloProxy </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (HelloImpl) proxy.</span><span style="color:#B392F0;">getProxy</span><span style="color:#E1E4E8;">(HelloImpl.class);</span></span>
<span class="line"><span style="color:#6A737D;">        // 调用代理对象的方法, 打印出before和after</span></span>
<span class="line"><span style="color:#E1E4E8;">        helloProxy.</span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Tom&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">        /**</span></span>
<span class="line"><span style="color:#6A737D;">         * 打印两次before和after</span></span>
<span class="line"><span style="color:#6A737D;">         * hello方法中调用了sayHello方法, 两个方法都会被拦截到而执行代理对象的方法</span></span>
<span class="line"><span style="color:#6A737D;">         */</span></span>
<span class="line"><span style="color:#E1E4E8;">        helloProxy.</span><span style="color:#B392F0;">hello</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Tom&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">        // 调用代理对象的方法, 打印出before和after</span></span>
<span class="line"><span style="color:#E1E4E8;">        helloProxy.</span><span style="color:#B392F0;">test</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>JDK的动态代理是通过接口实现机制, CGLib的动态代理是利用字节码增强技术通过父类方法拦截机制. CGLib创建的动态代理对象性能比JDK创建的动态代理对象的性能高, 但是CGLib在创建代理对象时所花费的时间却比JDK多得多, 所以对于单例的对象, 无需频繁创建对象, 用CGLib合适, 反之, 使用JDK方式要更为合适一些. 同时, 由于CGLib由于是采用动态创建子类的方法, 对于<code>final</code>方法, 无法进行代理.</p>`,5);function h(g,B){const a=r("RouteLink");return c(),t("div",null,[n("p",null,[s("之前在"),l(a,{to:"/program/java/2016-01-14-java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84.html"},{default:e(()=>[s("java中的反射")]),_:1}),s(" 一文中讲到"),E,s("时就涉及到的JDK的动态代理, 后来在Spring中使用AOP的时候, 发现有的方法拦截不到, 才意识到, Spring的AOP默认是使用JDK动态代理实现的, 必须实现接口才可以拦截到, 因此又写了这边文章")]),y,n("p",null,[s("使用CGLib动态代理要用到的类有:"),d,s(", "),v,s(", "),u,s(", 在之前"),l(a,{to:"/program/java/2015-11-26-Spring%E7%9A%84AOP.html"},{default:e(()=>[s("Spring的AOP")]),_:1}),s(" 中已经提到过, Spring3.2以后已经把"),m,s("包包含进了"),b,s(". 所以这几个类可以直接使用Spring中提供的.")]),F])}const x=o(i,[["render",h],["__file","2016-08-31-动态代理.html.vue"]]),j=JSON.parse('{"path":"/program/java/2016-08-31-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html","title":"动态代理","lang":"zh-CN","frontmatter":{"title":"动态代理","date":"2016-08-31T00:00:00.000Z","category":"Java","tag":["Java"],"order":-20160831,"description":"之前在 一文中讲到InvocationHandler时就涉及到的JDK的动态代理, 后来在Spring中使用AOP的时候, 发现有的方法拦截不到, 才意识到, Spring的AOP默认是使用JDK动态代理实现的, 必须实现接口才可以拦截到, 因此又写了这边文章 JDK动态代理使用示例 JDK的动态代理是依赖于接口实现的,因此要先定义接口,然后在定义接口...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/java/2016-08-31-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"动态代理"}],["meta",{"property":"og:description","content":"之前在 一文中讲到InvocationHandler时就涉及到的JDK的动态代理, 后来在Spring中使用AOP的时候, 发现有的方法拦截不到, 才意识到, Spring的AOP默认是使用JDK动态代理实现的, 必须实现接口才可以拦截到, 因此又写了这边文章 JDK动态代理使用示例 JDK的动态代理是依赖于接口实现的,因此要先定义接口,然后在定义接口..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-09T09:40:25.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2016-08-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-09T09:40:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动态代理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-08-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-09T09:40:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"JDK动态代理使用示例","slug":"jdk动态代理使用示例","link":"#jdk动态代理使用示例","children":[]},{"level":2,"title":"CGLib动态代理","slug":"cglib动态代理","link":"#cglib动态代理","children":[]}],"git":{"createdTime":1719158757000,"updatedTime":1725874825000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/java/2016-08-31-动态代理.md","localizedDate":"2016年8月31日","excerpt":"","autoDesc":true}');export{x as comp,j as data};
