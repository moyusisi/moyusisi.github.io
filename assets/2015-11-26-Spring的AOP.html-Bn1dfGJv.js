import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as a,d as n}from"./app-DJRQkAjL.js";const l={},t=n(`<p>在Spring中使用AOP的详细资料可以查看<a href="http://shouce.jb51.net/spring/aop.html" target="_blank" rel="noopener noreferrer">这里</a></p><h2 id="aop的实现方式" tabindex="-1"><a class="header-anchor" href="#aop的实现方式"><span>AOP的实现方式</span></a></h2><p>在Java中,从织入切面的方式上来看,存在三种织入方式:编译时织入、加载时织入和运行时织入</p><ul><li>编译时织入(Compile Time Weaving, CTW)</li></ul><p>指在Java编译期,采用特殊的编译器, 将切面织入到Java类中,即发生在从java文件到class文件的过程.<br> 这种方式将切面直接编译进了字节码，所以运行时不再需要动态创建代理对象, 节约了内存和CPU, 但编译过程复杂(可借助Maven AspectJ插件)，编写aspect文件(.aj文件)复杂</p><ul><li>加载时织入(Load Time Weaving, LTW)</li></ul><p>指通过特殊的类加载器(如AspectJ compiler), 在JVM载入字节码文件时, 织入切面, 即发生在class文件加载的过程.<br> 具体可参考<a href="http://shouce.jb51.net/spring/aop.html#aop-aj-ltw" target="_blank" rel="noopener noreferrer">这里</a></p><ul><li>运行时织入</li></ul><p>采用CGLib工具或JDK动态代理进行切面的织入, 如Spring AOP</p><h2 id="aop、cglib、spring-aop、aspectj之间的关系" tabindex="-1"><a class="header-anchor" href="#aop、cglib、spring-aop、aspectj之间的关系"><span>AOP、CGLib、Spring AOP、AspectJ之间的关系</span></a></h2><ul><li>AOP, Aspect Oriented Programming, 面向切面编程,是个概念, 类似于面向对象编程(OOP)一样</li><li>CGLib, 基于<code>asm.jar</code>的字节码增强技术API, 开源的, 也是个jar包:<code>cglib.jar</code></li><li>Spring AOP, Spring的AOP实现, 在运行时基于动态代理(JDK或cglib)的方式进行织入, Spring3.2以后不再需要依赖<code>cglib.jar</code>包, 因为它里面的类已经被<code>spring-core.jar</code>包含了</li><li>AspectJ, 提供了完整的AOP实现 <ol><li>AspectJ是一个代码生成工具,于自己的语法编译工具，编译的结果是Java Class文件, 支持编译时织入切面，即所谓的CTW机制</li><li>AspectJ有自己的类装载器，支持在类装载时织入切面，即所谓的LTW机制</li><li>AspectJ同样也支持运行时织入，运行时织入是基于动态代理的(默认机制)</li></ol></li></ul><h2 id="spring中aop相关的概念" tabindex="-1"><a class="header-anchor" href="#spring中aop相关的概念"><span>Spring中AOP相关的概念</span></a></h2><p>在怎么使用之前,最好先看看相关概念,有关<code>Joinpoint</code>、<code>Pointcut</code>、<code>Advice</code>等概念,看<a href="http://shouce.jb51.net/spring/aop.html#aop-introduction-defn" target="_blank" rel="noopener noreferrer">这里</a></p><h2 id="启用-aspectj支持" tabindex="-1"><a class="header-anchor" href="#启用-aspectj支持"><span>启用@AspectJ支持</span></a></h2><p>在Spring中使用<code>@AspectJ</code>可以在配置文件中启用<code>&lt;aop:aspectj-autoproxy/&gt;</code>, 甚至启用LTW机制<code>&lt;context:load-time-weaver/&gt;</code>, 对应的注解分别为<code>@EnableAspectJAutoProxy</code>和<code>@EnableLoadTimeWeaving</code></p><h2 id="声明一个切面" tabindex="-1"><a class="header-anchor" href="#声明一个切面"><span>声明一个切面</span></a></h2><p>在带有<code>@AspectJ</code>注解的类上同时加上<code>@Component</code>(声明为一个bean)注解并确保被自动扫描, 这样才会被Spring识别并管理</p><h2 id="声明一个切入点" tabindex="-1"><a class="header-anchor" href="#声明一个切入点"><span>声明一个切入点</span></a></h2><p>切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行, 即从哪里把要做的操作(通知)切入进去<br> 一个切入点声明有两个部分: <em>切入点签名</em> 和 <em>切入点表达式</em><br> 在<code>@AspectJ</code>注解风格的AOP中, <em>切入点签名</em> 通过一个普通的方法定义来提供, 该方法必需反回<code>void</code>类型;<br><em>切入点表达式</em> 使用<code>@Pointcut</code>注解来表示(内容略多, 后面讲), 一个切入点声明如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Pointcut</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;execution(* sayAdvisorBefore(..)) &amp;&amp; args(param)&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">argNames</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;param&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> pointcutName</span><span style="color:#E1E4E8;">(String param) {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>value: 指定切入点表达式, 如<code>execution</code>、<code>args</code>等</li><li>argNames: 指定该切入点方法参数列表,多个用<code>,</code>分隔,这些参数将传递给通知方法同名的参数;</li><li>pointcutName: 切入点名字，可以用该名字引用该切入点表达式</li></ul><h2 id="声明通知" tabindex="-1"><a class="header-anchor" href="#声明通知"><span>声明通知</span></a></h2><p><code>@AspectJ</code>风格的声明通知支持5种通知类型:</p><ul><li><code>@Before</code>: 前置通知,执行连接点方法之前执行</li><li><code>@AfterReturning</code>: 后置返回通知, 一个匹配的方法返回的时候执行</li><li><code>@AfterThrowing</code>: 异常通知, 在一个方法抛出异常后执行</li><li><code>@After</code>: 最终通知, 不论一个方法是如何结束的,最终通知都会运行, 最终通知必须准备处理正常返回和异常返回两种情况</li><li><code>@Around</code>: 环绕通知, 在一个方法执行之前和之后执行, 而且它可以决定这个方法在什么时候执行，如何执行，甚至是否执行. 通知的第一个参数必须是<code>ProceedingJoinPoint</code>类型,在通知体内，调用<code>ProceedingJoinPoint</code>的<code>proceed()</code>方法会导致 后台的连接点方法执行</li></ul><p>如果在同一个连接点上执行多个通知,可以使用<code>@Order</code>注解决定其执行顺序</p><p>下面是通知的使用方式:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Before</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;切入点表达式或命名切入点&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">argNames</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;参数列表参数名&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">After</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#F97583;">  =</span><span style="color:#9ECBFF;"> &quot;切入点表达式或命名切入点&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">argNames</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;参数列表参数名&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Around</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;切入点表达式或命名切入点&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">argNames</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;参数列表参数名&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">AfterReturning</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#79B8FF;">value</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;切入点表达式或命名切入点&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#79B8FF;">pointcut</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;切入点表达式或命名切入点&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 如果指定了将覆盖value属性指定的，pointcut具有高优先级</span></span>
<span class="line"><span style="color:#79B8FF;">argNames</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;参数列表参数名&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#79B8FF;">returning</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;返回值对应参数名&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">AfterThrowing</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#79B8FF;">value</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;切入点表达式或命名切入点&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#79B8FF;">pointcut</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;切入点表达式或命名切入点&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#79B8FF;">argNames</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;参数列表参数名&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#79B8FF;">throwing</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;异常对应参数名&quot;</span><span style="color:#E1E4E8;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>来个小例子:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Aspect</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> BeforeExample</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Before</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;pointcutName(param)&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">argNames</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &quot;param&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> beforeAdvice</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">param</span><span style="color:#E1E4E8;">) {  </span><span style="color:#6A737D;">// 切入点匹配到的参数将传递过来</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(param);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例使用<code>@Before</code>进行前置通知声明,其中value用于定义切入点表达式或引用命名切入点</p><h2 id="通知参数" tabindex="-1"><a class="header-anchor" href="#通知参数"><span>通知参数</span></a></h2><p>通知方法可以获取被通知方法的参数，主要是通过<code>JoinPoint</code>(环绕通知是<code>JoinPoint</code>的子类<code>ProceedingJoinPoint</code>)来获取, <code>JoinPoint</code>必须是第一个参数, Spring会自动传入.</p><p><code>JoinPoint</code>的声明如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> interface</span><span style="color:#B392F0;"> ProceedingJoinPoint</span><span style="color:#F97583;"> extends</span><span style="color:#B392F0;"> JoinPoint</span><span style="color:#E1E4E8;"> {  </span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">proceed</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Throwable;    </span><span style="color:#6A737D;">// 执行连接点的方法</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">proceed</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Throwable; </span><span style="color:#6A737D;">// 执行连接点的方法,可以把原来的参数用新的args替换掉</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 如果我这么声明切点: @Pointcut(&quot;within(com.test.spring.bean.Hello))&quot;)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> interface</span><span style="color:#B392F0;"> JoinPoint</span><span style="color:#E1E4E8;"> {  </span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">();          </span><span style="color:#6A737D;">// execution(String com.test.spring.bean.Hello.hello(String))</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">toShortString</span><span style="color:#E1E4E8;">();     </span><span style="color:#6A737D;">// execution(Hello.hello(..))</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">toLongString</span><span style="color:#E1E4E8;">();      </span><span style="color:#6A737D;">// execution(public java.lang.String com.test.spring.bean.Hello.hello(java.lang.String))</span></span>
<span class="line"><span style="color:#6A737D;">    // 上面这几个toString, 是打印切点相关信息, 注意上面是用 within声明 而打印出来的是 execution.</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">getThis</span><span style="color:#E1E4E8;">();           </span><span style="color:#6A737D;">//返回AOP代理对象  </span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">getTarget</span><span style="color:#E1E4E8;">();         </span><span style="color:#6A737D;">//返回目标对象(被代理的对象)  </span></span>
<span class="line"><span style="color:#F97583;">    Object</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">getArgs</span><span style="color:#E1E4E8;">();         </span><span style="color:#6A737D;">//返回被通知方法参数列表  </span></span>
<span class="line"><span style="color:#E1E4E8;">    Signature </span><span style="color:#B392F0;">getSignature</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">//返回当前连接点签名  </span></span>
<span class="line"><span style="color:#E1E4E8;">    SourceLocation </span><span style="color:#B392F0;">getSourceLocation</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">//返回连接点方法所在类文件中的位置  </span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getKind</span><span style="color:#E1E4E8;">();           </span><span style="color:#6A737D;">//连接点类型  </span></span>
<span class="line"><span style="color:#E1E4E8;">    StaticPart </span><span style="color:#B392F0;">getStaticPart</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">//返回连接点静态部分</span></span>
<span class="line"><span style="color:#6A737D;">    // 这是个内部接口, 提供访问连接点的静态部分，如被通知方法签名、连接点类型等</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> interface</span><span style="color:#B392F0;"> StaticPart</span><span style="color:#E1E4E8;"> {  </span></span>
<span class="line"><span style="color:#E1E4E8;">        Signature </span><span style="color:#B392F0;">getSignature</span><span style="color:#E1E4E8;">();    </span><span style="color:#6A737D;">//返回当前连接点签名  </span></span>
<span class="line"><span style="color:#E1E4E8;">        String </span><span style="color:#B392F0;">getKind</span><span style="color:#E1E4E8;">();            </span><span style="color:#6A737D;">//连接点类型  </span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#B392F0;"> getId</span><span style="color:#E1E4E8;">();                 </span><span style="color:#6A737D;">//唯一标识  </span></span>
<span class="line"><span style="color:#E1E4E8;">        String </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">();           </span><span style="color:#6A737D;">//连接点所在位置的相关信息  </span></span>
<span class="line"><span style="color:#E1E4E8;">        String </span><span style="color:#B392F0;">toShortString</span><span style="color:#E1E4E8;">();      </span><span style="color:#6A737D;">//连接点所在位置的简短相关信息  </span></span>
<span class="line"><span style="color:#E1E4E8;">        String </span><span style="color:#B392F0;">toLongString</span><span style="color:#E1E4E8;">();       </span><span style="color:#6A737D;">//连接点所在位置的全部相关信息  </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Signature</code>中的部分方法说明如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> interface</span><span style="color:#B392F0;"> Signature</span><span style="color:#E1E4E8;"> {  </span></span>
<span class="line"><span style="color:#6A737D;">    // Signature代表的是切点处的签名信息</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">();       </span><span style="color:#6A737D;">// String com.test.spring.bean.Hello.hello(String)</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">toShortString</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// Hello.hello(..)</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">toLongString</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">// public java.lang.String com.test.spring.bean.Hello.hello(java.lang.String)</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">();        </span><span style="color:#6A737D;">// hello 可参考:java.lang.reflect.Member.getName</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="切入点表达式" tabindex="-1"><a class="header-anchor" href="#切入点表达式"><span>切入点表达式</span></a></h2><p>切入点表达式就是组成<code>@Pointcut</code>注解的值, 用于匹配具体的连接点.<br> 切入点表达式由切入点指示符、类型匹配语句、通配符、组合符组成</p><p><strong>切入点指示符(PCD)</strong><br> 在切入点表达式中可以使用如下的AspectJ切入点指示符(PCD):</p><ul><li>execution: 匹配方法, 这是最经常的切入点指示符</li><li>within: 匹配特定类型之内的全部方法</li><li>this: 用于匹配当前AOP代理对象类型的连接点,包括接口</li><li>target: 用于匹配当前目标对象类型的连接点,不包括接口</li><li>args: 用于匹配当前执行的方法传入的参数为指定类型的连接点</li><li>@within: 匹配持有指定注解的类型里面的所有方法(注解在类上)</li><li>@target: 用于匹配当前目标对象类型的连接点，其中目标对象持有指定的注解</li><li>@args: 匹配当前执行的方法传入的参数持有指定的注解</li><li>@annotation: 匹配持有指定注解的方法(注解在方法上)</li></ul><p>看不明白还是看最后面的例子吧</p><p><strong>类型匹配语句</strong><br> 类型匹配语句格式像下面这样(带<code>?</code>的属于可选,可以不写):</p><ul><li>对类的匹配: <code>注解? 类的全限定名字</code></li><li>对方法的匹配: <code>注解? 修饰符? 返回值类型 类型声明? 方法名(参数列表) 异常列表？</code></li></ul><p><strong>类型匹配的通配符</strong></p><ul><li><code>*</code>: 匹配任何数量字符；</li><li><code>..</code>:(两个点)匹配任何数量字符的重复;如在类型模式中匹配任何数量子包,而在方法参数模式中匹配任何数量参数</li><li><code>+</code>: 匹配指定类型的子类型,仅能作为后缀放在类型模式后边</li></ul><p><strong>组合切入点表达式</strong><br> AspectJ使用 与(&amp;&amp;)、或(||)、非(!)来组合切入点表达式, 在xml文件中可使用and、or、not</p><h2 id="切入点表达式示例" tabindex="-1"><a class="header-anchor" href="#切入点表达式示例"><span>切入点表达式示例</span></a></h2><ul><li><code>execution</code>使用<code>execution(方法表达式)</code>匹配方法执行</li></ul><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>public * *(..)</td><td>所有public方法</td></tr><tr><td>* cn.test..IService.*()</td><td>cn.test及子包下IService中任何无参方法</td></tr><tr><td>* cn.test..IService＋.*()</td><td>cn.test及子包下IService及子类中任何无参方法</td></tr><tr><td>* cn.test..IService.*(＊)</td><td>cn.test及子包下IService中只有一个参数的方法</td></tr><tr><td>* cn.test..IService.*(..)</td><td>cn.test及子包下IService中所有方法</td></tr><tr><td>* cn.test..IService.*(java.util.Date)</td><td>cn.test及子包下IService中只有一个Date类型参数的方法</td></tr><tr><td>* cn.test..IService*.test*(..)</td><td>cn.test及子包下IService前缀类型中test前缀开头的任何方法</td></tr><tr><td>* cn.test..<em>.</em>(..)</td><td>cn.test及子包下任何类的任何方法</td></tr><tr><td>@java.lang.Deprecated * *(..)</td><td>任何持有@Deprecated注解的方法</td></tr><tr><td>@(java.lang.Deprecated &amp;&amp; cn.javass..Secure) * *(..)</td><td>任何持有@java.lang.Deprecated和@ cn.javass..Secure注解的方法</td></tr></tbody></table><ul><li><code>within</code>使用<code>within(类型表达式)</code>匹配指定类型内的方法执行</li></ul><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>within(cn.test..*)</td><td>cn.test及子包下的任何方法</td></tr><tr><td>within(cn.test..IService＋)</td><td>cn.test及子包下IService及子类的任何方法</td></tr><tr><td>within(@cn.test.Secure *)</td><td>cn.test及子包下带有@cn.test.Secure注解的任何类(接口不行)的任何方法</td></tr></tbody></table><ul><li><code>this</code>使用<code>this(类型全限定名)</code>匹配当前AOP代理对象类型的执行方法,包括引入接口,不支持通配符</li></ul><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>this(cn.test.IService)</td><td>当前AOP对象实现了IService接口的任何方法</td></tr></tbody></table><ul><li><code>target</code>使用<code>target(类型全限定名)</code>匹配当前目标对象类型的执行方法,不包括引入接口,不支持通配符</li></ul><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>target(cn.test.IService)</td><td>当前目标对象(非AOP对象)实现了IService接口的任何方法</td></tr></tbody></table><ul><li><code>args</code>使用<code>args(参数类型列表)</code>匹配传入参数(不是声明时的参数)为指定类型的执行方法,参数类型必须是全限定名, 不支持通配符</li></ul><p>args属于动态切入点，这种切入点开销非常大，非特殊情况最好不要使用</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>args(java.lang.String, ..)</td><td>第一个参数为String,后面有任意个参数的方法</td></tr></tbody></table><ul><li><code>@within</code>使用<code>@within(注解类型全限定名)</code>匹配所有持有指定注解的类里面的方法, 即要把注解加在类上</li></ul><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>@within(cn.test.Secure)</td><td>任何目标对象对应的类型持有Secure注解的类方法</td></tr></tbody></table><ul><li><code>@target</code>使用<code>@target(注解类型全限定名)</code>匹配当前目标对象类型的执行方法, 必须是在目标对象上声明注解，在接口上声明不起作用</li></ul><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>@target(cn.test.Secure)</td><td>任何目标对象对应的类型持有Secure注解的类方法</td></tr></tbody></table><ul><li><code>@args</code>使用<code>@args(注解类型全限定名)</code>匹配当前执行的方法传入的参数持有指定注解的执行</li></ul><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>@args(cn.test.Secure)</td><td>任何只接受一个参数的方法，且方法运行时传入的参数持有Secure注解</td></tr></tbody></table><ul><li><code>@annotation</code>使用<code>@annotation(注解类型全限定名)</code>匹配持有指定注解的方法, 即要把注解加在方法上才管用</li></ul><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>@annotation(cn.test.Secure)</td><td>当前执行方法上持有Secure注解的方法</td></tr></tbody></table>`,66),o=[t];function p(r,c){return e(),a("div",null,o)}const E=s(l,[["render",p],["__file","2015-11-26-Spring的AOP.html.vue"]]),y=JSON.parse('{"path":"/program/backend/2015-11-26-Spring%E7%9A%84AOP.html","title":"Spring的AOP","lang":"zh-CN","frontmatter":{"title":"Spring的AOP","date":"2015-11-26T00:00:00.000Z","category":"Spring","tag":["AOP"],"order":-20151126,"description":"在Spring中使用AOP的详细资料可以查看这里 AOP的实现方式 在Java中,从织入切面的方式上来看,存在三种织入方式:编译时织入、加载时织入和运行时织入 编译时织入(Compile Time Weaving, CTW) 指在Java编译期,采用特殊的编译器, 将切面织入到Java类中,即发生在从java文件到class文件的过程. 这种方式将切面...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/backend/2015-11-26-Spring%E7%9A%84AOP.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"Spring的AOP"}],["meta",{"property":"og:description","content":"在Spring中使用AOP的详细资料可以查看这里 AOP的实现方式 在Java中,从织入切面的方式上来看,存在三种织入方式:编译时织入、加载时织入和运行时织入 编译时织入(Compile Time Weaving, CTW) 指在Java编译期,采用特殊的编译器, 将切面织入到Java类中,即发生在从java文件到class文件的过程. 这种方式将切面..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T15:13:58.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"AOP"}],["meta",{"property":"article:published_time","content":"2015-11-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-23T15:13:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring的AOP\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2015-11-26T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-23T15:13:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"AOP的实现方式","slug":"aop的实现方式","link":"#aop的实现方式","children":[]},{"level":2,"title":"AOP、CGLib、Spring AOP、AspectJ之间的关系","slug":"aop、cglib、spring-aop、aspectj之间的关系","link":"#aop、cglib、spring-aop、aspectj之间的关系","children":[]},{"level":2,"title":"Spring中AOP相关的概念","slug":"spring中aop相关的概念","link":"#spring中aop相关的概念","children":[]},{"level":2,"title":"启用@AspectJ支持","slug":"启用-aspectj支持","link":"#启用-aspectj支持","children":[]},{"level":2,"title":"声明一个切面","slug":"声明一个切面","link":"#声明一个切面","children":[]},{"level":2,"title":"声明一个切入点","slug":"声明一个切入点","link":"#声明一个切入点","children":[]},{"level":2,"title":"声明通知","slug":"声明通知","link":"#声明通知","children":[]},{"level":2,"title":"通知参数","slug":"通知参数","link":"#通知参数","children":[]},{"level":2,"title":"切入点表达式","slug":"切入点表达式","link":"#切入点表达式","children":[]},{"level":2,"title":"切入点表达式示例","slug":"切入点表达式示例","link":"#切入点表达式示例","children":[]}],"git":{"createdTime":1719155638000,"updatedTime":1719155638000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/backend/2015-11-26-Spring的AOP.md","localizedDate":"2015年11月26日","excerpt":"","autoDesc":true}');export{E as comp,y as data};
