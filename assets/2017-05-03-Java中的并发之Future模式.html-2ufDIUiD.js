import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as a,d as l}from"./app-ZaGLpo4p.js";const e={},p=l(`<p>Java的多线程编程中经常用到<code>Future模式</code>, 本文就简单介绍下<code>Future模式</code></p><h2 id="future模式" tabindex="-1"><a class="header-anchor" href="#future模式"><span>Future模式</span></a></h2><p><code>Future模式</code>的核心在于: 去除了主函数的等待时间，使原本需要等待的时间段可以用于处理其他业务逻辑.<br><code>Future模式</code>的关键在于: 返回的数据并不是真实的处理结果<code>RealData</code>, 而是一个代理数据<code>FutureData</code>, 当调用代理数据的<code>get</code>方法时(<code>FutureData.get()</code>), 会阻塞等待获取真实数据<code>RealData</code>.</p><p>下面实现一个简易版的<code>Future模式</code>, 这个例子很好的说明了<code>Future.get()</code>时的阻塞的形成原理</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * FutureData实际上是真实数据RealData的代理, 封装了获取RealData的等待过程</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> FutureData</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">implements</span><span style="color:#B392F0;"> Future</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> V realData </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;        </span><span style="color:#6A737D;">// FutureData是realData的封装</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> boolean</span><span style="color:#E1E4E8;"> isReady </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> false</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 是否已经准备好</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> synchronized</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> setRealData</span><span style="color:#E1E4E8;">(V </span><span style="color:#FFAB70;">realData</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (isReady)</span></span>
<span class="line"><span style="color:#F97583;">            return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.realData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> realData;</span></span>
<span class="line"><span style="color:#E1E4E8;">        isReady </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#B392F0;">        notifyAll</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// realData已经被注入到FutureData中, 通知get()方法(因为get方法里在等待锁)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> synchronized</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">isReady) {</span></span>
<span class="line"><span style="color:#B392F0;">            wait</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">//一直等到realData注入到FutureData中</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> realData;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // Future的其他接口略...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要使用我们自己实现的简易版<code>Future模式</code>, 我们需要一个在一个方法里加工一些数据并最后返回我们的<code>FutureData</code></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> Future </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">        final</span><span style="color:#E1E4E8;"> FutureData futureData </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> FutureData</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">        // 假设生成realData的过程特别慢, 所以放在单独的线程中运行</span></span>
<span class="line"><span style="color:#F97583;">        new</span><span style="color:#B392F0;"> Thread</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Runnable</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">            public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">                String realData </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &quot;假设生成realData的过程特别慢&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">                futureData.</span><span style="color:#B392F0;">setRealData</span><span style="color:#E1E4E8;">(realData);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }).</span><span style="color:#B392F0;">start</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> futureData; </span><span style="color:#6A737D;">// 直接返回FutureData</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样当我们调用<code>Future futureData = doSomething()</code>来处理数据的时候, 要加工的数据特别慢, 我们直接返回了<code>FutureData</code>, 所以在调用<code>doSomething()</code>的线程里并不被阻塞, 这个线程可以去做其他事情, 只有当这个线程通过<code>futureData.get()</code>时, 线程才会被阻塞, 直到返回<code>realData</code>.</p><h2 id="futuretask详解" tabindex="-1"><a class="header-anchor" href="#futuretask详解"><span>FutureTask详解</span></a></h2><p>JDK中<code>Future模式</code>的经典实现类为<code>FutureTask</code>, 它除了实现了<code>Future</code>接口外还实现了<code>Runnable</code>接口, 它的实现比我们简易版的实现要复杂一些</p><ul><li><code>FutureTask</code>本身实现了<code>Future</code>(就像上面的<code>FutureData</code>), 我们执行了这个<code>FutureTask</code>之后, 想要获取结果可以使用<code>FutureTask.get()</code>来获取真实数据</li><li><code>FutureTask</code>自己实现了<code>Runnable</code>接口, 也就是说我们我们不用再另起线程来执行某任务了(就像<code>doSomething()</code>里做的), 可以直接使用<code>Thread</code>去启动这个<code>FutureTask</code>或者把它交给一个<code>ExecutorService</code>去执行.</li></ul><h3 id="futuretask的结构" tabindex="-1"><a class="header-anchor" href="#futuretask的结构"><span>FutureTask的结构</span></a></h3><p><code>FutureTask</code>内部的主要成员如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 任务的状态</span></span>
<span class="line"><span style="color:#6A737D;">     * 可能的状态转换:</span></span>
<span class="line"><span style="color:#6A737D;">     * NEW -&gt; COMPLETING -&gt; NORMAL</span></span>
<span class="line"><span style="color:#6A737D;">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span>
<span class="line"><span style="color:#6A737D;">     * NEW -&gt; CANCELLED</span></span>
<span class="line"><span style="color:#6A737D;">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> volatile</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> state;</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> NEW          </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 初始化的状态(包括任务未启动, 任务执行中, 任务刚跑完)</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> COMPLETING   </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 完成中, 这是个过渡状态, 任务跑完了但是还没给outcome赋值</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> NORMAL       </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 已完成</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> EXCEPTIONAL  </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 3</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 运行中出现了异常</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> CANCELLED    </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 4</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 已取消</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> INTERRUPTING </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 5</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 正在中断</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> INTERRUPTED  </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 6</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 已中断</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    /** 可执行的任务, 即最后的结果是由它计算出来的; 运行结束后将被设置为null */</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> Callable&lt;</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; callable;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 用于存放get()时要返回的结果或者异常 */</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> Object outcome;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 执行callable的那个线程 */</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> volatile</span><span style="color:#E1E4E8;"> Thread runner;</span></span>
<span class="line"><span style="color:#6A737D;">    /** 用于存放等待任务结果的线程, 即调用get()的那些被阻塞的线程都用这个链表来保存, 以便于结果完成时把等待的线程唤醒 */</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> volatile</span><span style="color:#E1E4E8;"> WaitNode waiters;</span></span>
<span class="line"><span style="color:#6A737D;">    // WaitNode 类定义</span></span>
<span class="line"><span style="color:#F97583;">    static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> WaitNode</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">        volatile</span><span style="color:#E1E4E8;"> Thread thread;</span></span>
<span class="line"><span style="color:#F97583;">        volatile</span><span style="color:#E1E4E8;"> WaitNode next;</span></span>
<span class="line"><span style="color:#B392F0;">        WaitNode</span><span style="color:#E1E4E8;">() { thread </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">(); }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法"><span>构造方法</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    public</span><span style="color:#B392F0;"> FutureTask</span><span style="color:#E1E4E8;">(Callable</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> callable) {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (callable </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">            throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> NullPointerException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.callable </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callable;</span></span>
<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.state </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NEW;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#B392F0;"> FutureTask</span><span style="color:#E1E4E8;">(Runnable runnable, V result) {</span></span>
<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.callable </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">callable</span><span style="color:#E1E4E8;">(runnable, result);  </span><span style="color:#6A737D;">// 把runnable转成了callable</span></span>
<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.state </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NEW;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到成员变量里只有一个<code>callable</code>, 而构造方法里传入<code>Runnable 或 Callable</code>都可以, 在构造方法里已经把<code>Runnable</code>转化成了<code>Callable</code>. 我们也可以这样声明一个不需要返回值的task: <code>Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)</code></p><h3 id="run方法" tabindex="-1"><a class="header-anchor" href="#run方法"><span>run方法</span></a></h3><p><code>run()</code>方法是真正执行任务获取最终数据的地方</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (state </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> NEW </span><span style="color:#F97583;">||</span><span style="color:#6A737D;">  // 如果状态不是 NEW, 短路或就会直接返回, 只有状态 是NEW的时候才会执行后面的CAS</span></span>
<span class="line"><span style="color:#F97583;">            !</span><span style="color:#E1E4E8;">UNSAFE.</span><span style="color:#B392F0;">compareAndSwapObject</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, runnerOffset, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">()))</span></span>
<span class="line"><span style="color:#6A737D;">            // 这句CAS的意思为 this.runner == null ? (this.runner = 当前线程, 然后返回true) : (返回 false)</span></span>
<span class="line"><span style="color:#6A737D;">            // CAS是一个原子操作, 整个if的意思是, 只有状态为NEW且头一回被线程执行(this.runner == null)才会把当前线程赋值给 this.runner</span></span>
<span class="line"><span style="color:#F97583;">            return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            Callable&lt;</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callable;</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#E1E4E8;"> state </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> NEW) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                V result;</span></span>
<span class="line"><span style="color:#F97583;">                boolean</span><span style="color:#E1E4E8;"> ran;  </span><span style="color:#6A737D;">// 是否正常运行完得到结果的标识</span></span>
<span class="line"><span style="color:#F97583;">                try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 处理过程, 获取最终结果的过程</span></span>
<span class="line"><span style="color:#E1E4E8;">                    ran </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 虽然此时已经处理完了获取了result, 但在调用 set 之前state一直是NEW</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">ex</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 出了异常的情况</span></span>
<span class="line"><span style="color:#E1E4E8;">                    result </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    ran </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#B392F0;">                    setException</span><span style="color:#E1E4E8;">(ex); </span><span style="color:#6A737D;">// state状态变换 NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#F97583;">                if</span><span style="color:#E1E4E8;"> (ran)</span></span>
<span class="line"><span style="color:#B392F0;">                    set</span><span style="color:#E1E4E8;">(result);  </span><span style="color:#6A737D;">// state状态变换 NEW -&gt; COMPLETING -&gt; NORMAL</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">            // runner must be non-null until state is settled to</span></span>
<span class="line"><span style="color:#6A737D;">            // prevent concurrent calls to run()</span></span>
<span class="line"><span style="color:#E1E4E8;">            runner </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">            // state must be re-read after nulling runner to prevent</span></span>
<span class="line"><span style="color:#6A737D;">            // leaked interrupts</span></span>
<span class="line"><span style="color:#F97583;">            int</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> state;</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> INTERRUPTING)</span></span>
<span class="line"><span style="color:#B392F0;">                handlePossibleCancellationInterrupt</span><span style="color:#E1E4E8;">(s);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="set方法" tabindex="-1"><a class="header-anchor" href="#set方法"><span>set方法</span></a></h3><p>不管是<code>set()</code>还是<code>setException()</code>, 都大同小异, 他们两个都调用了<code>finishCompletion()</code>方法</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    protected</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> set</span><span style="color:#E1E4E8;">(V v) {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (UNSAFE.</span><span style="color:#B392F0;">compareAndSwapInt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, stateOffset, NEW, COMPLETING)) {  </span><span style="color:#6A737D;">// 这里状态变成 COMPLETING</span></span>
<span class="line"><span style="color:#E1E4E8;">            outcome </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> v; </span><span style="color:#6A737D;">// 把结果放在 outcome(出现异常时, 异常也放在outcome)</span></span>
<span class="line"><span style="color:#E1E4E8;">            UNSAFE.</span><span style="color:#B392F0;">putOrderedInt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, stateOffset, NORMAL); </span><span style="color:#6A737D;">// 把state改成NORMAL, 但不保证立即改过来(可理解为延时生效, 即不保证修改立即可见)</span></span>
<span class="line"><span style="color:#B392F0;">            finishCompletion</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 这个方法很重要, 它用来唤醒所有的阻塞线程</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> finishCompletion</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">        // 外层是个循环, 很有必要</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (WaitNode q; (q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> waiters) </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;) {</span></span>
<span class="line"><span style="color:#6A737D;">            // 代码执行到这里是有可能产生 q != waiters 的情况的, 比如刚进入循环, 又有个地方因调用future.get()</span></span>
<span class="line"><span style="color:#6A737D;">            // 而被加入到阻塞链表里, 这时if就不满足了, 所以外层必须是个循环才能继续执行唤醒工作</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (UNSAFE.</span><span style="color:#B392F0;">compareAndSwapObject</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, waitersOffset, q, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)) { </span><span style="color:#6A737D;">// 原子操作 waiters = null</span></span>
<span class="line"><span style="color:#F97583;">                for</span><span style="color:#E1E4E8;"> (;;) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    Thread t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> q.thread;</span></span>
<span class="line"><span style="color:#F97583;">                    if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        q.thread </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                        LockSupport.</span><span style="color:#B392F0;">unpark</span><span style="color:#E1E4E8;">(t);  </span><span style="color:#6A737D;">// 唤醒阻塞线程</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                    WaitNode next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> q.next;</span></span>
<span class="line"><span style="color:#F97583;">                    if</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 唤醒所有阻塞线程后跳出死循环</span></span>
<span class="line"><span style="color:#F97583;">                        break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    q.next </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// unlink to help gc</span></span>
<span class="line"><span style="color:#E1E4E8;">                    q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#F97583;">                break</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 跳出外层循环(不用担心在唤醒的的时候又有新线程被添加到阻塞链表里, get方法中可以保证)</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#B392F0;">        done</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        callable </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">// 清理执行足迹</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="get方法" tabindex="-1"><a class="header-anchor" href="#get方法"><span>get方法</span></a></h3><p>不管是<code>get()</code>是获取最终结果的方法, 如果结果数据还没准备好, 则调用线程将被阻塞, 被记录在<code>FutureTask</code>的阻塞链表(<code>waiters</code>)里.</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> state;</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> COMPLETING)</span></span>
<span class="line"><span style="color:#E1E4E8;">            s </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> awaitDone</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0L</span><span style="color:#E1E4E8;">);  </span><span style="color:#6A737D;">// 真正的阻塞发生在这里</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#B392F0;"> report</span><span style="color:#E1E4E8;">(s); </span><span style="color:#6A737D;">// 根据状态返回结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 根据state返回结果, 结果或异常都在outcome里</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">report</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> s) throws ExecutionException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> outcome;</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> NORMAL)  </span><span style="color:#6A737D;">// 正常结束返回结果</span></span>
<span class="line"><span style="color:#F97583;">            return</span><span style="color:#E1E4E8;"> (V)x;</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> CANCELLED)  </span><span style="color:#6A737D;">// 取消了抛异常</span></span>
<span class="line"><span style="color:#F97583;">            throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> CancellationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">        throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> ExecutionException</span><span style="color:#E1E4E8;">((Throwable)x); </span><span style="color:#6A737D;">// 执行过程中产生的异常直接抛出</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 等待(可以等待一段时间, 时间到就不再等了)</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> int</span><span style="color:#B392F0;"> awaitDone</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> timed, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> nanos)</span></span>
<span class="line"><span style="color:#E1E4E8;">        throws InterruptedException {</span></span>
<span class="line"><span style="color:#F97583;">        final</span><span style="color:#F97583;"> long</span><span style="color:#E1E4E8;"> deadline </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> timed </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">nanoTime</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> nanos </span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0L</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        WaitNode q </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        boolean</span><span style="color:#E1E4E8;"> queued </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> false</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 这个变量表示有没有把当前线程加入到阻塞链表中去</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (;;) { </span><span style="color:#6A737D;">// 这个循环会被执行很多次, 每次都匹配到条件执行, 直到复合特定条件才直接返回结果</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (Thread.</span><span style="color:#B392F0;">interrupted</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#B392F0;">                removeWaiter</span><span style="color:#E1E4E8;">(q);</span></span>
<span class="line"><span style="color:#F97583;">                throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> InterruptedException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#F97583;">            int</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> state;  </span><span style="color:#6A737D;">// 这里注意跟set中同步, 有可能刚得到s, sate就被更改了</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> COMPLETING) {  </span><span style="color:#6A737D;">// 这里保证只有 NEW 和 COMPLETING 才不会直接返回</span></span>
<span class="line"><span style="color:#F97583;">                if</span><span style="color:#E1E4E8;"> (q </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                    q.thread </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">                return</span><span style="color:#E1E4E8;"> s;  </span><span style="color:#6A737D;">// 这里的跳出循环并返回结果, 实际上只有任务完成(或被取消)才会执行到</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#F97583;">            else</span><span style="color:#F97583;"> if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> COMPLETING) </span><span style="color:#6A737D;">// 这里把 COMPLETING 也排除掉了, 也就是说, 往下走的情况只有 s = NEW</span></span>
<span class="line"><span style="color:#E1E4E8;">                Thread.</span><span style="color:#B392F0;">yield</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">            else</span><span style="color:#F97583;"> if</span><span style="color:#E1E4E8;"> (q </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">                q </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> WaitNode</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">            else</span><span style="color:#F97583;"> if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">queued)</span></span>
<span class="line"><span style="color:#6A737D;">                // 头插法(q.next指向原表头, 并把q赋值给了waiters, 相当于q放在了链表头), 成功返回true表示已经加入到了阻塞链表.</span></span>
<span class="line"><span style="color:#6A737D;">                // 这一切发生的前提是 waitersOffset == waiters, 这并不总是成立,</span></span>
<span class="line"><span style="color:#6A737D;">                // 因为有可能刚好在q.next = waiters之后(此时得到了waiters, 假设用tmp表示),</span></span>
<span class="line"><span style="color:#6A737D;">                // set方法里把futureTask.waiters改成了null. 这时就会出现waitersOffset != waiters(tmp)的情况</span></span>
<span class="line"><span style="color:#E1E4E8;">                queued </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UNSAFE.</span><span style="color:#B392F0;">compareAndSwapObject</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, waitersOffset, q.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> waiters, q);</span></span>
<span class="line"><span style="color:#F97583;">            else</span><span style="color:#F97583;"> if</span><span style="color:#E1E4E8;"> (timed) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                nanos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> deadline </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">nanoTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">                if</span><span style="color:#E1E4E8;"> (nanos </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 0L</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#B392F0;">                    removeWaiter</span><span style="color:#E1E4E8;">(q);</span></span>
<span class="line"><span style="color:#F97583;">                    return</span><span style="color:#E1E4E8;"> state;  </span><span style="color:#6A737D;">// 如果设置了等待时间, 时间到了也会跳出循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                LockSupport.</span><span style="color:#B392F0;">parkNanos</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, nanos);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#F97583;">            else</span></span>
<span class="line"><span style="color:#E1E4E8;">                LockSupport.</span><span style="color:#B392F0;">park</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,26),o=[p];function t(c,r){return a(),n("div",null,o)}const d=s(e,[["render",t],["__file","2017-05-03-Java中的并发之Future模式.html.vue"]]),y=JSON.parse('{"path":"/program/backend/2017-05-03-Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B9%8BFuture%E6%A8%A1%E5%BC%8F.html","title":"Java中的并发之Future模式","lang":"zh-CN","frontmatter":{"title":"Java中的并发之Future模式","date":"2017-05-03T00:00:00.000Z","category":"Java","tag":["Java"],"order":-20170411,"description":"Java的多线程编程中经常用到Future模式, 本文就简单介绍下Future模式 Future模式 Future模式的核心在于: 去除了主函数的等待时间，使原本需要等待的时间段可以用于处理其他业务逻辑. Future模式的关键在于: 返回的数据并不是真实的处理结果RealData, 而是一个代理数据FutureData, 当调用代理数据的get方法时...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/backend/2017-05-03-Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B9%8BFuture%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"Java中的并发之Future模式"}],["meta",{"property":"og:description","content":"Java的多线程编程中经常用到Future模式, 本文就简单介绍下Future模式 Future模式 Future模式的核心在于: 去除了主函数的等待时间，使原本需要等待的时间段可以用于处理其他业务逻辑. Future模式的关键在于: 返回的数据并不是真实的处理结果RealData, 而是一个代理数据FutureData, 当调用代理数据的get方法时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T16:41:59.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2017-05-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-23T16:41:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java中的并发之Future模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2017-05-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-23T16:41:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"Future模式","slug":"future模式","link":"#future模式","children":[]},{"level":2,"title":"FutureTask详解","slug":"futuretask详解","link":"#futuretask详解","children":[{"level":3,"title":"FutureTask的结构","slug":"futuretask的结构","link":"#futuretask的结构","children":[]},{"level":3,"title":"构造方法","slug":"构造方法","link":"#构造方法","children":[]},{"level":3,"title":"run方法","slug":"run方法","link":"#run方法","children":[]},{"level":3,"title":"set方法","slug":"set方法","link":"#set方法","children":[]},{"level":3,"title":"get方法","slug":"get方法","link":"#get方法","children":[]}]}],"git":{"createdTime":1719160919000,"updatedTime":1719160919000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/backend/2017-05-03-Java中的并发之Future模式.md","localizedDate":"2017年5月3日","excerpt":"","autoDesc":true}');export{d as comp,y as data};
