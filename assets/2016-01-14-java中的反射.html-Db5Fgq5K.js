import{_ as l}from"./reflect_interface-DhCJLQ1c.js";import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as c,c as p,a as e,b as s,e as r,w as d,d as a}from"./app-BG82UnuN.js";const i={},E=a('<p>java反射涉及到的内容有点多，但不难，主要是一些之前没见过的类型，本文先简单介绍一部分</p><h2 id="反射相关的类和接口简介" tabindex="-1"><a class="header-anchor" href="#反射相关的类和接口简介"><span>反射相关的类和接口简介</span></a></h2><p>在<code>java.lang.reflect</code>包中定义了一些接口和类,简单记录下他们的作用</p><h3 id="相关类说明" tabindex="-1"><a class="header-anchor" href="#相关类说明"><span>相关类说明</span></a></h3><p>这些类都比较简单，对照API一看就懂，主要是平时用到的比较少，这里先简单说明下，不在此展开</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>AccessibleObject</td><td><code>Field、Method</code>和<code>Constructor</code>对象的基类</td></tr><tr><td>Field</td><td>final类, 对应类或接口的单个字段</td></tr><tr><td>Method</td><td>final类, 对应类或接口的单独某个方法</td></tr><tr><td><code>Constructor&lt;T&gt;</code></td><td>final类, 对应类的单个构造方法</td></tr><tr><td>Modifier</td><td>对应类和成员访问修饰符, 如<code>public,static,final,native,synchronized</code>等</td></tr><tr><td>Array</td><td>final类, 对应数组</td></tr><tr><td>Proxy</td><td>提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类</td></tr><tr><td>ReflectPermission</td><td>final类, 反射操作的<code>Permission</code>类</td></tr></tbody></table><p>另外反射机制还经常用到<code>java.lang</code>中的类, 如<code>Class</code>、<code>Packate</code>还有各种原始类型等</p><h3 id="相关接口继承关系图" tabindex="-1"><a class="header-anchor" href="#相关接口继承关系图"><span>相关接口继承关系图</span></a></h3><figure><img src="'+l+'" alt="反射相关接口继承关系图" tabindex="0" loading="lazy"><figcaption>反射相关接口继承关系图</figcaption></figure><h3 id="相关接口说明" tabindex="-1"><a class="header-anchor" href="#相关接口说明"><span>相关接口说明</span></a></h3><p>这里先简单介绍下，后文还会详细说明这些接口</p><table><thead><tr><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>AnnotatedElement</td><td>被注解标注的元素都实现的接口<br> 实现类有<code>AccessibleObject</code>及其子类,<code>Class``Package</code></td></tr><tr><td>Member</td><td>成员接口, 反映字段、方法、构造函数的信息<br></td></tr><tr><td>Type</td><td>所有类型的父接口, 之后的文章会详细介绍</td></tr><tr><td>GenericDeclaration</td><td>各种声明类型的父接口, 如<code>Class,Constructor,Method</code></td></tr><tr><td><code>TypeVariable&lt;D extends GenericDeclaration&gt;</code></td><td>类型变量类型</td></tr><tr><td>ParameterizedType</td><td>参数化类型, 如<code>Collection&lt;String&gt;</code></td></tr><tr><td>GenericArrayType</td><td>数组类型, 它里面的元素为参数化类型或类型变量(上面那俩)</td></tr><tr><td>WildcardType</td><td>通配符类型, 如<code>&lt;?&gt;, &lt;? extends Number&gt;, &lt;? super Integer&gt;</code></td></tr><tr><td>InvocationHandler</td><td>代理处理器接口</td></tr></tbody></table><h2 id="object-class和type的关系和区别" tabindex="-1"><a class="header-anchor" href="#object-class和type的关系和区别"><span><code>Object</code>, <code>Class</code>和<code>Type</code>的关系和区别</span></a></h2><p>所有的类都继承<code>Object</code>是毫无疑问的, <code>Class</code>也是类，也继承<code>Object</code><br><code>Class</code>类特殊的地方是它在运行时用来描述类的各种元信息,对象是类的实例,而类在运行时的描述就是<code>Class</code><br><code>Type</code>是个接口,用来表示某个对象是什么类型的,<code>Class</code>类实现了好几个接口,其中一个就是<code>Type</code><br> 后面的文章内容更能体现出区别来</p><h2 id="反射的具体功能" tabindex="-1"><a class="header-anchor" href="#反射的具体功能"><span>反射的具体功能</span></a></h2><p>反射作用挺多, 比如反编译, 通过反射机制访问对象的属性、方法、构造方法等, 先简单给出一些示例</p><h3 id="获取类" tabindex="-1"><a class="header-anchor" href="#获取类"><span>获取类</span></a></h3><p>有如下三种方法:</p><ol><li>通过<code>Class.forName()</code>, 如:<code>Class clazz = Class.forName(&quot;java.lang.String&quot;);</code></li><li>通过类的<code>class</code>属性, 如:<code>Class clazz = String.class;</code></li><li>通过实例对象的<code>getClass</code>方法, 如: <code>Class clazz = user.getClass();</code></li></ol><h3 id="获取对象实例" tabindex="-1"><a class="header-anchor" href="#获取对象实例"><span>获取对象实例</span></a></h3><ol><li>通过<code>Class</code>实例的<code>newInstance()</code>, 如:<code>String str = (String)clazz.newInstance();</code></li></ol><h2 id="反射相关接口的详细说明" tabindex="-1"><a class="header-anchor" href="#反射相关接口的详细说明"><span>反射相关接口的详细说明</span></a></h2>',22),y=e("code",null,"AnnotatedElement、Member、InvocationHandler、GenericDeclaration",-1),m=e("br",null,null,-1),h=e("code",null,"Type",-1),v=a(`<h3 id="annotatedelement" tabindex="-1"><a class="header-anchor" href="#annotatedelement"><span>AnnotatedElement</span></a></h3><p>这个接口最简单, 实现了该接口的类都能添加注解, 其实现类有: <code>AccessibleObject, Class, Constructor, Field, Method, Package</code><br> 它有如下方法:</p><ol><li><code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>: 该类上是否存在<code>annotationClass</code>这个注解</li><li><code>Annotation[] getAnnotations()</code>: 获取这个元素上的所有注解(包括父类上被<code>@Inherited</code>标记的注解)</li><li><code>&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)</code>: 获取这个元素上指定类型的注解, 没有返回null</li><li><code>Annotation[] getDeclaredAnnotations()</code>: 获取直接标注在这个元素上的注解</li></ol><h3 id="member" tabindex="-1"><a class="header-anchor" href="#member"><span>Member</span></a></h3><p>表示组成类的成员, 其实现类有: <code>Constructor, Field, Method</code> 它有如下方法:</p><ol><li><code>boolean isSynthetic()</code>: 是否是复合类</li><li><code>int getModifiers()</code>: 以数字形式返回修饰符</li><li><code>String getName()</code>: 返回成员的简单名, 如: 属性名字, 方法名字(只有名字,不包括参数), 构造器名字</li><li><code>Class&lt;?&gt; getDeclaringClass()</code>: 返回声明该成员的声明类</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// getName方法的测试</span></span>
<span class="line"><span style="color:#F97583;">package</span><span style="color:#E1E4E8;"> com.test;</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> TestMember</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> String name;              </span><span style="color:#6A737D;">// 属性名为: name</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> hello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">name</span><span style="color:#E1E4E8;">) {} </span><span style="color:#6A737D;">// 方法名(不包括参数)为: hello</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#B392F0;"> TestMember</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">name</span><span style="color:#E1E4E8;">) {} </span><span style="color:#6A737D;">// 构造器名为: com.test.TestMember</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(TestMember.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;name&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());                    </span><span style="color:#6A737D;">// name</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(TestMember.class.</span><span style="color:#B392F0;">getDeclaredMethod</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;hello&quot;</span><span style="color:#E1E4E8;">, String.class).</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">// hello</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(TestMember.class.</span><span style="color:#B392F0;">getDeclaredConstructor</span><span style="color:#E1E4E8;">(String.class).</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());        </span><span style="color:#6A737D;">//com.test.TestMember</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(TestMember.class.</span><span style="color:#B392F0;">getDeclaredField</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;name&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">getDeclaringClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());</span><span style="color:#6A737D;">//com.test.TestMember</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="invocationhandler" tabindex="-1"><a class="header-anchor" href="#invocationhandler"><span>InvocationHandler</span></a></h3><p>代理处理器类的实例需要实现的接口, 只有一个方法:</p><ol><li><code>Object invoke(Object proxy, Method method, Object[] args)</code>: 代理对象执行方法时真正调用的函数</li></ol><p>其中:</p><ul><li><code>Object proxy</code>: 表示代理对象(比如通过<code>Proxy.newProxyInstance()</code>得到的对象), 不是实现了该接口的代理处理器对象</li><li><code>Method method</code>: 被代理对象的方法, 就是接口原来实现类里的方法, 代理对象执行的时候会调用被代理对象的方法(取决于代码怎么写)</li><li><code>Object[] args</code>: 上面那个方法需要的参数</li></ul><p>通常代理处理器类的实例<code>handler</code>会作为参数传到java代理类<code>Proxy</code>的<code>newProxyInstance</code>方法中来产生一个代理对象(与被代理对象实现了同一接口)<br> 调用代理对象的方法时, 真正调用的就是上面的invoke函数.<br> 还是来个例子吧(<code>HelloImpl</code>实现了<code>Hello</code>接口, 并实现了<code>sayHello()</code>方法)</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// 代理处理器类</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> AOPHandler</span><span style="color:#F97583;"> implements</span><span style="color:#B392F0;"> InvocationHandler</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#E1E4E8;"> Object target;  </span><span style="color:#6A737D;">// 这个用来表示被代理的对象</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#B392F0;"> AOPHandler</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.target </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> target;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">proxy</span><span style="color:#E1E4E8;">, Method </span><span style="color:#FFAB70;">method</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;proxy:&quot;</span><span style="color:#F97583;"> +</span><span style="color:#E1E4E8;"> proxy.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());   </span><span style="color:#6A737D;">// proxy:com.sun.proxy.$Proxy0</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;method:&quot;</span><span style="color:#F97583;"> +</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// proxy:java.lang.reflect.Method</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(target, args);  </span><span style="color:#6A737D;">// 调用被代理对象的的方法, 即 target 的 method</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 测试类</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> ProxyTest</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object obj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Class.</span><span style="color:#B392F0;">forName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;com.test.HelloImpl&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">newInstance</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        InvocationHandler handler </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> AOPHandler</span><span style="color:#E1E4E8;">(obj);  </span><span style="color:#6A737D;">// 创建代理处理器对象的时候把被代理的对象传进去</span></span>
<span class="line"><span style="color:#6A737D;">        // 这里生成代理类对象, 参数依次为: 被代理对象的ClassLoader, 被代理对象实现的所有接口, 代理处理器</span></span>
<span class="line"><span style="color:#E1E4E8;">        Hello proxy </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (Hello) Proxy.</span><span style="color:#B392F0;">newProxyInstance</span><span style="color:#E1E4E8;">(obj.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getClassLoader</span><span style="color:#E1E4E8;">(), obj.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getInterfaces</span><span style="color:#E1E4E8;">(), handler);</span></span>
<span class="line"><span style="color:#E1E4E8;">        proxy.</span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 这就调用了那个invoke方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="genericdeclaration" tabindex="-1"><a class="header-anchor" href="#genericdeclaration"><span>GenericDeclaration</span></a></h3><p>可以声明类型变量的实体的公共接口, 就是那些能够声明范型类型<code>&lt;T&gt;</code>的地方, 注意是声明而不是使用.其实现类有: <code>Class, Constructor, Method</code><br> 它就一个方法:</p><ol><li><code>TypeVariable&lt;?&gt;[] getTypeParameters()</code>: 按照声明顺序返回声明的类型变量</li></ol><p>对它可以这么理解:<br> 在定义类或方法时, 我们一般可以声明范型, 如<code>&lt;T&gt; T getData()</code>, 因此可以声明这些<code>&lt;T&gt;、&lt;F&gt;</code>的实体, 都实现了该接口;<br> 而那些声明出来的<code>T、F</code>叫类型变量(<code>TypeVariable</code>), 后面会说到.</p>`,18);function b(u,g){const n=t("RouteLink");return c(),p("div",null,[E,e("p",null,[s("这些接口的关系可参考上面那幅图, 这里只详细说明"),y,s("这几个接口"),m,h,s("接口及其字类在"),r(n,{to:"/program/code/2016-02-16-Type%E8%AF%A6%E8%A7%A3.html"},{default:d(()=>[s("Type详解")]),_:1}),s("中详细说明")]),v])}const C=o(i,[["render",b],["__file","2016-01-14-java中的反射.html.vue"]]),j=JSON.parse('{"path":"/program/code/2016-01-14-java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84.html","title":"java中的反射","lang":"zh-CN","frontmatter":{"title":"java中的反射","date":"2016-01-14T00:00:00.000Z","category":"Java","tag":["反射"],"order":-20160114,"description":"java反射涉及到的内容有点多，但不难，主要是一些之前没见过的类型，本文先简单介绍一部分 反射相关的类和接口简介 在java.lang.reflect包中定义了一些接口和类,简单记录下他们的作用 相关类说明 这些类都比较简单，对照API一看就懂，主要是平时用到的比较少，这里先简单说明下，不在此展开 另外反射机制还经常用到java.lang中的类, 如C...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/code/2016-01-14-java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"java中的反射"}],["meta",{"property":"og:description","content":"java反射涉及到的内容有点多，但不难，主要是一些之前没见过的类型，本文先简单介绍一部分 反射相关的类和接口简介 在java.lang.reflect包中定义了一些接口和类,简单记录下他们的作用 相关类说明 这些类都比较简单，对照API一看就懂，主要是平时用到的比较少，这里先简单说明下，不在此展开 另外反射机制还经常用到java.lang中的类, 如C..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-16T03:30:34.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"反射"}],["meta",{"property":"article:published_time","content":"2016-01-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-16T03:30:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java中的反射\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-01-14T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-16T03:30:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"反射相关的类和接口简介","slug":"反射相关的类和接口简介","link":"#反射相关的类和接口简介","children":[{"level":3,"title":"相关类说明","slug":"相关类说明","link":"#相关类说明","children":[]},{"level":3,"title":"相关接口继承关系图","slug":"相关接口继承关系图","link":"#相关接口继承关系图","children":[]},{"level":3,"title":"相关接口说明","slug":"相关接口说明","link":"#相关接口说明","children":[]}]},{"level":2,"title":"Object, Class和Type的关系和区别","slug":"object-class和type的关系和区别","link":"#object-class和type的关系和区别","children":[]},{"level":2,"title":"反射的具体功能","slug":"反射的具体功能","link":"#反射的具体功能","children":[{"level":3,"title":"获取类","slug":"获取类","link":"#获取类","children":[]},{"level":3,"title":"获取对象实例","slug":"获取对象实例","link":"#获取对象实例","children":[]}]},{"level":2,"title":"反射相关接口的详细说明","slug":"反射相关接口的详细说明","link":"#反射相关接口的详细说明","children":[{"level":3,"title":"AnnotatedElement","slug":"annotatedelement","link":"#annotatedelement","children":[]},{"level":3,"title":"Member","slug":"member","link":"#member","children":[]},{"level":3,"title":"InvocationHandler","slug":"invocationhandler","link":"#invocationhandler","children":[]},{"level":3,"title":"GenericDeclaration","slug":"genericdeclaration","link":"#genericdeclaration","children":[]}]}],"git":{"createdTime":1719158757000,"updatedTime":1723779034000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/code/2016-01-14-java中的反射.md","localizedDate":"2016年1月14日","excerpt":"","autoDesc":true}');export{C as comp,j as data};
