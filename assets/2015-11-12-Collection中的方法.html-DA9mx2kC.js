import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o as d,c as a,a as e,b as o,e as n,w as r,d as l}from"./app-BG82UnuN.js";const s="/assets/collection-CWP3IQHt.png",p={},u=l('<p>Java中Collection的继承关系图, 虚线表示接口, 实线表示类</p><h2 id="collection继承关系图" tabindex="-1"><a class="header-anchor" href="#collection继承关系图"><span>Collection继承关系图</span></a></h2><figure><img src="'+s+'" alt="Collection继承关系图" tabindex="0" loading="lazy"><figcaption>Collection继承关系图</figcaption></figure><h2 id="collection基本操作" tabindex="-1"><a class="header-anchor" href="#collection基本操作"><span>Collection基本操作</span></a></h2>',4),h=e("li",null,[e("code",null,"int size()"),o(": 返回集合大小")],-1),m=e("li",null,[e("code",null,"boolean isEmpty()"),o(": 是否为空")],-1),E=e("li",null,[e("code",null,"Iterator<E> iterator()"),o(": 返回迭代器")],-1),y=e("li",null,[e("code",null,"Object[] toArray()"),o(": 把集合转成数组")],-1),g=e("code",null,"<T> T[] toArray(T[] a)",-1),b=l("<li><code>boolean contains(Object o)</code>: 是否包含该对象</li><li><code>boolean containsAll(Collection&lt;?&gt; c)</code>: 包含c里的全部元素则返回true</li><li><code>boolean add(E e)</code>: 添加成功改变了集合则返回true</li><li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>: 全部添加</li><li><code>boolean remove(E e)</code>: 移除元素</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: 相当于减集合c</li><li><code>boolean retainAll(Collection&lt;?&gt; c)</code>: 相当于求与c的交集</li><li><code>void clear()</code>: 清空集合</li>",8),_=l('<h2 id="set接口" tabindex="-1"><a class="header-anchor" href="#set接口"><span>Set接口</span></a></h2><ul><li>Set不允许包含相同的元素, 而判断两个对象是否相同则是根据<code>equals</code>方法</li><li><code>HashSet</code>不是同步的, 不能保证元素的排列顺序, 注意<code>hashCode</code>方法的实现</li><li><code>LinkedHashSet</code>根据元素的<code>hashCode</code>值来决定元素的存储位置，但它同时使用链表维护元素的次序</li><li><code>TreeSet</code>是<code>SortedSet</code>接口的实现类, 有顺序, 可自定义比较器(<code>Comparator</code>),有<code>first、last、lower、higher</code>等方法</li></ul><h2 id="list接口" tabindex="-1"><a class="header-anchor" href="#list接口"><span>List接口</span></a></h2><p><code>List</code>是经常用到的工具, 是有序集合, 增加了与索引位置相关的操作:</p><ul><li><code>E get(int index)</code>: 获取指定位置的元素</li><li><code>E set(int index, E element)</code>: 替换指定位置的元素</li><li><code>void add(int index, E element)</code>: 将元素添加到指定位置</li><li><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>: 将c里的元素添加到指定位置</li><li><code>E remove(int index)</code>: 移除指定位置的元素</li><li><code>int indexOf(Object o)</code>: o在list中第一次出现的位置</li><li><code>int lastIndexOf(Object o)</code>: o在list中最后一次出现的位置</li><li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>: 子list</li></ul><h3 id="arraylist和vector" tabindex="-1"><a class="header-anchor" href="#arraylist和vector"><span>ArrayList和Vector</span></a></h3><p><code>ArrayList</code>是线程不安全的,而<code>Vector</code>是线程安全的</p><h3 id="stack" tabindex="-1"><a class="header-anchor" href="#stack"><span>Stack</span></a></h3><p><code>Stack</code>是<code>Vector</code>的子类,模拟数据结构中的栈,有下面几个操作:</p><ul><li><code>E push(E item)</code>: 压栈</li><li><code>E pop()</code>: 出栈</li><li><code>E peek()</code>: 查看栈顶元素, 不出栈</li><li><code>boolean empty()</code>: 判断栈空</li><li><code>int search(Object o)</code>: 返回元素位置, 栈顶元素是1, －1表示栈里没有</li></ul><h2 id="queue接口" tabindex="-1"><a class="header-anchor" href="#queue接口"><span>Queue接口</span></a></h2><p><code>Queue</code>用于模拟队列这种数据结构，实现先进先出&quot;FIFO&quot;等数据结构,常用如下操作:</p><ul><li><code>boolean add(E e)</code>: 不建议使用</li><li><code>boolean offer(E e)</code>: 将指定元素插入队尾列,当使用有容量限制的队列时,此方法通常要优于<code>add(E)</code>, 后者可能无法插入元素，而只是抛出一个异常。<strong>推荐使用此方法取代add</strong></li><li><code>boolean remove()</code>: 不建议使用</li><li><code>boolean poll()</code>: 获取头部元素并且删除元素，队列为空返回null;<strong>推荐使用此方法取代remove</strong></li><li><code>boolean element()</code>: 返回队首元素, 队空抛<code>NoSuchElementException</code></li><li><code>boolean peek()</code>: 返回队首元素, 队空返回<code>null</code></li></ul><h3 id="priorityqueue类" tabindex="-1"><a class="header-anchor" href="#priorityqueue类"><span>PriorityQueue类</span></a></h3><p><code>PriorityQueue</code>类中元素的顺序不是按照加入的顺序排列的, 而是按队列元素的优先级重新排序, 调用<code>peek()</code>或者是<code>poll()</code>方法时，返回的是队列中优先级最小的元素, 可以自定义排序.</p><h3 id="deque接口与arraydeque类" tabindex="-1"><a class="header-anchor" href="#deque接口与arraydeque类"><span>Deque接口与ArrayDeque类</span></a></h3><p><code>Deque</code>代表一个双端队列，可以当作一个双端队列使用，也可以当作“栈”来使用，因为它包含出栈<code>pop()</code>与入栈<code>push()</code>方法</p><ul><li><code>void addFirst(E e)</code>: 元素增加至队头, 超容量抛异常</li><li><code>void addLast(E e)</code>: 元素增加至队尾, 超容量抛异常</li><li><code>boolean offerFirst(E e)</code>: 元素增加至队头, 比add安全</li><li><code>boolean offerLast(E e)</code>: 元素增加至队尾, 比add安全</li><li><code>E removeFirst()</code>: 获取并删除队头元素, 队空抛<code>NoSuchElementException</code></li><li><code>E removeLast()</code>: 获取并删除队尾元素, 队空抛<code>NoSuchElementException</code></li><li><code>E pollFirst()</code>: 获取并删除队头元素, 队空返回<code>null</code></li><li><code>E pollLast()</code>: 获取并删除队尾元素, 队空返回<code>null</code></li><li><code>E getFirst()</code>: 获取队头元素, 但不删除, 队空抛<code>NoSuchElementException</code></li><li><code>E getLast()</code>: 获取队头元素, 但不删除, 队空抛<code>NoSuchElementException</code></li><li><code>E peekFirst()</code>: 获取队头元素, 但不删除, 队空返回<code>null</code></li><li><code>E peekLast()</code>: 获取队头元素, 但不删除, 队空返回<code>null</code></li><li><code>void push(E e)</code>: 元素增加至队头, 类似<code>offerFirst</code></li><li><code>E pop()</code>: 元素增加至队头, 类似<code>pollFirst</code></li></ul><h3 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist"><span>LinkedList</span></a></h3><p><code>LinkedList</code>类同时实现了<code>List</code>接口和<code>Deque</code>接口, 因此它也可以当做一个双端队列来用, 也可以当作“栈”来使用.<br> 它基于链表实现, 随机访问性能较差, 但插入与删除操作性能很好</p>',20);function C(f,v){const t=c("RouteLink");return d(),a("div",null,[u,e("ul",null,[h,m,E,y,e("li",null,[g,o(": 把集合转成数组，参考"),n(t,{to:"/program/code/2015-11-12-Collection%E7%9A%84toArray%E6%96%B9%E6%B3%95.html"},{default:r(()=>[o("Collection的toArray方法")]),_:1})]),b]),_])}const q=i(p,[["render",C],["__file","2015-11-12-Collection中的方法.html.vue"]]),L=JSON.parse('{"path":"/program/code/2015-11-12-Collection%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html","title":"Collection中的方法","lang":"zh-CN","frontmatter":{"title":"Collection中的方法","date":"2015-11-12T00:00:00.000Z","category":"Java","tag":["Java"],"order":-20151112,"description":"Java中Collection的继承关系图, 虚线表示接口, 实线表示类 Collection继承关系图 Collection继承关系图Collection继承关系图 Collection基本操作 int size(): 返回集合大小 boolean isEmpty(): 是否为空 Iterator<E> iterator(): 返回迭代器 Objec...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/code/2015-11-12-Collection%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"Collection中的方法"}],["meta",{"property":"og:description","content":"Java中Collection的继承关系图, 虚线表示接口, 实线表示类 Collection继承关系图 Collection继承关系图Collection继承关系图 Collection基本操作 int size(): 返回集合大小 boolean isEmpty(): 是否为空 Iterator<E> iterator(): 返回迭代器 Objec..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-16T03:30:34.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2015-11-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-16T03:30:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Collection中的方法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2015-11-12T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-16T03:30:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"Collection继承关系图","slug":"collection继承关系图","link":"#collection继承关系图","children":[]},{"level":2,"title":"Collection基本操作","slug":"collection基本操作","link":"#collection基本操作","children":[]},{"level":2,"title":"Set接口","slug":"set接口","link":"#set接口","children":[]},{"level":2,"title":"List接口","slug":"list接口","link":"#list接口","children":[{"level":3,"title":"ArrayList和Vector","slug":"arraylist和vector","link":"#arraylist和vector","children":[]},{"level":3,"title":"Stack","slug":"stack","link":"#stack","children":[]}]},{"level":2,"title":"Queue接口","slug":"queue接口","link":"#queue接口","children":[{"level":3,"title":"PriorityQueue类","slug":"priorityqueue类","link":"#priorityqueue类","children":[]},{"level":3,"title":"Deque接口与ArrayDeque类","slug":"deque接口与arraydeque类","link":"#deque接口与arraydeque类","children":[]},{"level":3,"title":"LinkedList","slug":"linkedlist","link":"#linkedlist","children":[]}]}],"git":{"createdTime":1719155638000,"updatedTime":1723779034000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/code/2015-11-12-Collection中的方法.md","localizedDate":"2015年11月12日","excerpt":"","autoDesc":true}');export{q as comp,L as data};
