import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as a,d as l}from"./app-DQ46ret3.js";const e="/assets/HashMap-C7z47TeP.png",p={},o=l('<p>本文是以<code>JDK7</code>中的<code>HashMap</code>进行介绍, 先整体介绍, 再单独介绍一些具体的点</p><h2 id="存储结构" tabindex="-1"><a class="header-anchor" href="#存储结构"><span>存储结构</span></a></h2><p><code>HashMap</code>的数据结构是数组加链表的形式。结构大体如下:</p><figure><img src="'+e+`" alt="HashMap结构图" tabindex="0" loading="lazy"><figcaption>HashMap结构图</figcaption></figure><p><code>HashMap</code>类中有个<code>table</code>属性, 是一个数组, 数组元素类型为<code>Entry</code>(内部类), 而<code>Entry</code>有<code>key, value, next, hash</code>四个属性。<br> 一般<code>table</code>数组的每个位置我们称为<code>bucket</code>, 下标称为<code>bucketIndex</code>, 即每一个位置表示一个<code>桶</code>, 同一个桶中的<code>Entry</code>元素<code>hash</code>值相同(<code>null</code>除外, 后面说)</p><h2 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数"><span>构造函数</span></a></h2><ul><li><code>HashMap(int initialCapacity, float loadFactor)</code>: 指定初始容量和负载因子</li><li><code>HashMap(int initialCapacity)</code>: 指定初始容量, 使用默认负载因子</li><li><code>HashMap()</code>: 使用默认初始容量和负载因子</li><li><code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>: 通过另一个map初始化, 容量取<code>m.size() / DEFAULT_LOAD_FACTOR) + 1</code>与默认初始容量两者较大的那个,使用默认负载因子</li></ul><h2 id="需要知道的概念" tabindex="-1"><a class="header-anchor" href="#需要知道的概念"><span>需要知道的概念</span></a></h2><p><code>HashMap</code>中有几个概念, 还有几个<code>成员属性</code>, 需要了解它们的意义:</p><ul><li><code>容量</code>: <code>table</code>数组的大小(<code>table.length</code>), 并没有一个属性来描述, 内部用<code>capacity()</code>函数来获取数组大小. 默认初始容量<code>DEFAULT_INITIAL_CAPACITY</code>为16, 每次扩容都扩大2倍.</li><li><code>size</code>: 该属性表示<code>key-value</code>对的元素个数, 即每新增一个<code>Entry</code>会加1, 每减少一个 <code>Entry</code>会减1</li><li><code>loadFactor</code>: 负载因子, 这相当于一个系数, 用于计算<code>threshold</code>. 默认负载因子<code>DEFAULT_LOAD_FACTOR</code>为0.75</li><li><code>threshold</code>: 阈值, 当<code>size</code>达到该阈值, 就需要扩容. 该阈值由<code>capacity * loadFactor</code>计算得到(构造函数里,直接<code>threshold = initialCapacity</code>, 但构造函数中没有给<code>table</code>分配空间, 分配空间时, 阈值由<code>Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1)</code>决定).</li><li><code>modCount</code>: 该属性可理解为对该map所做的修改次数, 比如增加或者减少一个<code>Entry</code>都会加1(<code>size</code>会变少, <code>modCount</code>只会变大)</li></ul><h2 id="关于hash" tabindex="-1"><a class="header-anchor" href="#关于hash"><span>关于hash</span></a></h2><p>既然是<code>HashMap</code>, 一定避免不了hash. <code>Object</code>都有<code>hashCode()</code>函数, 但在<code>HashMap</code>又提供了一个辅助哈希函数<code>hash(Object k)</code>, 这个函数在<code>JDK7</code>与<code>JDK8</code>中不同. 当<code>key</code>为<code>null</code>时, 是没有<code>hashCode()</code>的, 因此要单独处理. <code>JDK7</code>中有专门的<code>putForNullKey()</code>函数来把<code>null</code>放在下标为0的<code>bucket</code>中; 而<code>JDK8</code>直接在辅助哈希函数<code>hash()</code>中把<code>null</code>的哈希值设置为0.</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // JDK7</span></span>
<span class="line"><span style="color:#F97583;">    final</span><span style="color:#F97583;"> int</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(Object k) {</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> hashSeed;</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">0</span><span style="color:#F97583;"> !=</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> String) {</span></span>
<span class="line"><span style="color:#F97583;">            return</span><span style="color:#E1E4E8;"> sun.misc.Hashing.</span><span style="color:#B392F0;">stringHash32</span><span style="color:#E1E4E8;">((String) k);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        h </span><span style="color:#F97583;">^=</span><span style="color:#E1E4E8;"> k.</span><span style="color:#B392F0;">hashCode</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">        // This function ensures that hashCodes that differ only by</span></span>
<span class="line"><span style="color:#6A737D;">        // constant multiples at each bit position have a bounded</span></span>
<span class="line"><span style="color:#6A737D;">        // number of collisions (approximately 8 at default load factor).</span></span>
<span class="line"><span style="color:#E1E4E8;">        h </span><span style="color:#F97583;">^=</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#79B8FF;"> 20</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">^</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#79B8FF;"> 12</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">^</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#79B8FF;"> 7</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">^</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#79B8FF;"> 4</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">   // JDK8</span></span>
<span class="line"><span style="color:#F97583;">    static</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(Object key) {</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> h;</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> (key </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">?</span><span style="color:#79B8FF;"> 0</span><span style="color:#F97583;"> :</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> key.</span><span style="color:#B392F0;">hashCode</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">^</span><span style="color:#E1E4E8;"> (h </span><span style="color:#F97583;">&gt;&gt;&gt;</span><span style="color:#79B8FF;"> 16</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="计算桶坐标-bucketindex" tabindex="-1"><a class="header-anchor" href="#计算桶坐标-bucketindex"><span>计算桶坐标:bucketIndex</span></a></h2><p>这一步是用来计算数组下标(即应放到那个<code>bucket</code>中)的。 但是这一步很关键，也正好解释了很多问题，如:</p><ul><li>为什么初始容量<code>DEFAULT_INITIAL_CAPACITY</code>为16?</li><li>为什么扩容的时候是2倍扩容?</li><li>为什么容量总是2的次幂?(构造函数里传的初始容量为40, 最后得到的容量为64, 必须是2的次幂)</li></ul><p>计算数组下标的函数如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(key);  </span><span style="color:#6A737D;">// 辅助哈希函数</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> indexFor</span><span style="color:#E1E4E8;">(hash, table.length); </span><span style="color:#6A737D;">// 求桶坐标的函数</span></span>
<span class="line"><span style="color:#6A737D;">    // 具体实现</span></span>
<span class="line"><span style="color:#F97583;">    static</span><span style="color:#F97583;"> int</span><span style="color:#B392F0;"> indexFor</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> h, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length) {</span></span>
<span class="line"><span style="color:#6A737D;">        // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> (length</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正常来讲, 哈希值的索引一般通过<code>index = h % length</code>计算, 但是若<code>length</code>总是2的整数次幂, 就可以通过位运算<code>h &amp; (length-1)</code>来优化.</p><h2 id="添加元素put" tabindex="-1"><a class="header-anchor" href="#添加元素put"><span>添加元素put</span></a></h2><ul><li>刚创建的<code>HashMap</code>中的<code>table</code>是空的(<code>EMPTY_TABLE</code>), 真正添加元素的时候才回分配空间</li><li>添加元素时, 如果<code>key</code>一样, 会替换掉原来<code>Entry</code>的<code>value</code></li><li>添加元素时, 有可能涉及到扩容</li><li>新添加的元素位于链表头, 即<code>table[bucketIndex]</code>的位置</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    // JDK7 put方法</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(K key, V value) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 如果数组是空的, 需要根据初始容量来扩张. 默认构造函数中, threshold=initialCapacity</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (table </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> EMPTY_TABLE) {</span></span>
<span class="line"><span style="color:#B392F0;">            inflateTable</span><span style="color:#E1E4E8;">(threshold);  </span><span style="color:#6A737D;">// table大小为: a power of 2 &gt;= threshold</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (key </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">            return</span><span style="color:#B392F0;"> putForNullKey</span><span style="color:#E1E4E8;">(value);  </span><span style="color:#6A737D;">// null 放到 table[0] 的位置</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> indexFor</span><span style="color:#E1E4E8;">(hash, table.length);  </span><span style="color:#6A737D;">// 通过位运算得到桶的位置</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table[i]; e </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">; e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.next) {  </span><span style="color:#6A737D;">// 这个循环里, 处理该key已经存在的情况</span></span>
<span class="line"><span style="color:#E1E4E8;">            Object k;</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (e.hash </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> ((k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.key) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> key.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(k))) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                V oldValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.value;</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> value;</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.</span><span style="color:#B392F0;">recordAccess</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">                return</span><span style="color:#E1E4E8;"> oldValue;  </span><span style="color:#6A737D;">// 返回被替换掉的值</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        modCount</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 修改次数增加</span></span>
<span class="line"><span style="color:#B392F0;">        addEntry</span><span style="color:#E1E4E8;">(hash, key, value, i); </span><span style="color:#6A737D;">// 真正的添加元素</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 添加元素的函数</span></span>
<span class="line"><span style="color:#F97583;">    void</span><span style="color:#B392F0;"> addEntry</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> hash, K key, V value, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> bucketIndex) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 这就是需要扩容的条件(扩容的条件有2个)</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> ((size </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> threshold) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">null</span><span style="color:#F97583;"> !=</span><span style="color:#E1E4E8;"> table[bucketIndex])) {</span></span>
<span class="line"><span style="color:#B392F0;">            resize</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#F97583;"> *</span><span style="color:#E1E4E8;"> table.length);  </span><span style="color:#6A737D;">// 扩容是在这里进行的</span></span>
<span class="line"><span style="color:#E1E4E8;">            hash </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">null</span><span style="color:#F97583;"> !=</span><span style="color:#E1E4E8;"> key) </span><span style="color:#F97583;">?</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(key) </span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            bucketIndex </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> indexFor</span><span style="color:#E1E4E8;">(hash, table.length);  </span><span style="color:#6A737D;">// 扩容后重新计算桶的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#6A737D;">        // 新创建一个元素并添加到 bucketIndex 位置</span></span>
<span class="line"><span style="color:#B392F0;">        createEntry</span><span style="color:#E1E4E8;">(hash, key, value, bucketIndex);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    void</span><span style="color:#B392F0;"> createEntry</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> hash, K key, V value, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> bucketIndex) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table[bucketIndex];</span></span>
<span class="line"><span style="color:#E1E4E8;">        table[bucketIndex] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#E1E4E8;"> Entry&lt;&gt;(hash, key, value, e); </span><span style="color:#6A737D;">// 放到链表头</span></span>
<span class="line"><span style="color:#E1E4E8;">        size</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 元素数量+1</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="关于modcount" tabindex="-1"><a class="header-anchor" href="#关于modcount"><span>关于modCount</span></a></h2><p>平时使用<code>HashMap</code>遇到过的一个异常是<code>ConcurrentModificationException</code>. 这种情况是因为在使用迭代器的过程中, 增加或者删除了元素, 导致<code>modCount</code>变化导致的. 原因就在迭代器中:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// 迭代器构造方法</span></span>
<span class="line"><span style="color:#B392F0;">HashIterator</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    expectedModCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> modCount;  </span><span style="color:#6A737D;">// 创建迭代器的时候expectedModCount=modCount, 不相等的时候快速失败</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (size </span><span style="color:#F97583;">&gt;</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// advance to first entry</span></span>
<span class="line"><span style="color:#F97583;">        Entry</span><span style="color:#E1E4E8;">[] t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table;</span></span>
<span class="line"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (index </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> t.length </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t[index</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">]) </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 这里第一个有元素的桶(index为桶坐标)</span></span>
<span class="line"><span style="color:#E1E4E8;">            ;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 迭代器找下一个元素方法</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Entry</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#B392F0;"> nextEntry</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (modCount </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> expectedModCount) </span><span style="color:#6A737D;">// 在这里抛出异常, 快速失败</span></span>
<span class="line"><span style="color:#F97583;">        throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> ConcurrentModificationException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (e </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">        throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> NoSuchElementException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> ((next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.next) </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {  </span><span style="color:#6A737D;">// 如果 e.next是null, 就到了链表尾, 此时应该找下一个桶中的元素</span></span>
<span class="line"><span style="color:#F97583;">        Entry</span><span style="color:#E1E4E8;">[] t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table;</span></span>
<span class="line"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> (index </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> t.length </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t[index</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">]) </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)  </span><span style="color:#6A737D;">// 下一个有元素的桶</span></span>
<span class="line"><span style="color:#E1E4E8;">            ;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    current </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e;</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> e;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="关于扩容" tabindex="-1"><a class="header-anchor" href="#关于扩容"><span>关于扩容</span></a></h2><p><code>HashMap</code>扩容是通过<code>resize(int newCapacity)</code>函数实现的, 而扩容的时机, 则是在<code>put</code>函数里真正添加元素时调用<code>addEntry</code>来控制的.</p><p>扩容需要两个条件:</p><ol><li><code>size &gt;= threshold</code>: 元素个数达到阈值</li><li><code>null != table[bucketIndex]</code>: 新元素要放的桶中有元素(该桶中没有元素不会扩容)</li></ol><p>扩容过程如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">// 在 addEntry 中调用resize扩容</span></span>
<span class="line"><span style="color:#B392F0;">resize</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#F97583;"> *</span><span style="color:#E1E4E8;"> table.length); </span><span style="color:#6A737D;">// 每次都是2倍扩容</span></span>
<span class="line"><span style="color:#6A737D;">// resize函数</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> resize</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> newCapacity) { </span><span style="color:#6A737D;">// capacity MUST be a power of two</span></span>
<span class="line"><span style="color:#F97583;">    Entry</span><span style="color:#E1E4E8;">[] oldTable </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> table;</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> oldCapacity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> oldTable.length;</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (oldCapacity </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> MAXIMUM_CAPACITY) {  </span><span style="color:#6A737D;">// 最大容量时就不再扩容了</span></span>
<span class="line"><span style="color:#E1E4E8;">        threshold </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    Entry</span><span style="color:#E1E4E8;">[] newTable </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#F97583;"> Entry</span><span style="color:#E1E4E8;">[newCapacity];</span></span>
<span class="line"><span style="color:#B392F0;">    transfer</span><span style="color:#E1E4E8;">(newTable, </span><span style="color:#B392F0;">initHashSeedAsNeeded</span><span style="color:#E1E4E8;">(newCapacity)); </span><span style="color:#6A737D;">// 这里把原来的元素移动到新table中</span></span>
<span class="line"><span style="color:#E1E4E8;">    table </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newTable;</span></span>
<span class="line"><span style="color:#E1E4E8;">    threshold </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">)Math.</span><span style="color:#B392F0;">min</span><span style="color:#E1E4E8;">(newCapacity </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> loadFactor, MAXIMUM_CAPACITY </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 更新阈值</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 移动元素的 transfer 函数</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> transfer</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">Entry</span><span style="color:#E1E4E8;">[] newTable, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> rehash) {</span></span>
<span class="line"><span style="color:#F97583;">    int</span><span style="color:#E1E4E8;"> newCapacity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newTable.length;</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> table) {</span></span>
<span class="line"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#F97583;"> !=</span><span style="color:#E1E4E8;"> e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.next; </span><span style="color:#6A737D;">// 头插法</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (rehash) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                e.hash </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#F97583;"> ==</span><span style="color:#E1E4E8;"> e.key </span><span style="color:#F97583;">?</span><span style="color:#79B8FF;"> 0</span><span style="color:#F97583;"> :</span><span style="color:#B392F0;"> hash</span><span style="color:#E1E4E8;">(e.key);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#F97583;">            int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> indexFor</span><span style="color:#E1E4E8;">(e.hash, newCapacity); </span><span style="color:#6A737D;">// 新的桶位置(通过位运算来计算)</span></span>
<span class="line"><span style="color:#E1E4E8;">            e.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newTable[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">            newTable[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e;</span></span>
<span class="line"><span style="color:#E1E4E8;">            e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="关于并发" tabindex="-1"><a class="header-anchor" href="#关于并发"><span>关于并发</span></a></h2><p><code>HashMap</code>不是线程安全的, 一般还会提到一个不常用的但是线程安全的对象<code>Hashtable</code>, 它相当于<code>HashMap</code>的方法(包括<code>toString</code>)加锁(<code>synchronized</code>)来控制并发.</p><p>若要考虑并发问题, 一般推荐使用<code>ConcurrentHashMap</code>, 它通过<code>Segment</code>来实现分段加锁。</p>`,34),c=[o];function t(r,i){return a(),n("div",null,c)}const y=s(p,[["render",t],["__file","2017-03-08-HashMap详解.html.vue"]]),v=JSON.parse('{"path":"/program/backend/2017-03-08-HashMap%E8%AF%A6%E8%A7%A3.html","title":"HashMap详解","lang":"zh-CN","frontmatter":{"title":"HashMap详解","date":"2017-03-08T00:00:00.000Z","category":"Java","tag":["Java"],"order":-20170308,"description":"本文是以JDK7中的HashMap进行介绍, 先整体介绍, 再单独介绍一些具体的点 存储结构 HashMap的数据结构是数组加链表的形式。结构大体如下: HashMap结构图HashMap结构图 HashMap类中有个table属性, 是一个数组, 数组元素类型为Entry(内部类), 而Entry有key, value, next, hash四个属性...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/backend/2017-03-08-HashMap%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"HashMap详解"}],["meta",{"property":"og:description","content":"本文是以JDK7中的HashMap进行介绍, 先整体介绍, 再单独介绍一些具体的点 存储结构 HashMap的数据结构是数组加链表的形式。结构大体如下: HashMap结构图HashMap结构图 HashMap类中有个table属性, 是一个数组, 数组元素类型为Entry(内部类), 而Entry有key, value, next, hash四个属性..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T16:41:59.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2017-03-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-23T16:41:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2017-03-08T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-23T16:41:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"存储结构","slug":"存储结构","link":"#存储结构","children":[]},{"level":2,"title":"构造函数","slug":"构造函数","link":"#构造函数","children":[]},{"level":2,"title":"需要知道的概念","slug":"需要知道的概念","link":"#需要知道的概念","children":[]},{"level":2,"title":"关于hash","slug":"关于hash","link":"#关于hash","children":[]},{"level":2,"title":"计算桶坐标:bucketIndex","slug":"计算桶坐标-bucketindex","link":"#计算桶坐标-bucketindex","children":[]},{"level":2,"title":"添加元素put","slug":"添加元素put","link":"#添加元素put","children":[]},{"level":2,"title":"关于modCount","slug":"关于modcount","link":"#关于modcount","children":[]},{"level":2,"title":"关于扩容","slug":"关于扩容","link":"#关于扩容","children":[]},{"level":2,"title":"关于并发","slug":"关于并发","link":"#关于并发","children":[]}],"git":{"createdTime":1719160919000,"updatedTime":1719160919000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/backend/2017-03-08-HashMap详解.md","localizedDate":"2017年3月8日","excerpt":"","autoDesc":true}');export{y as comp,v as data};
