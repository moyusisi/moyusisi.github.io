import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as n,d as s}from"./app-DT7svUeb.js";const l={},o=s(`<p>回顾<code>Java</code>的基础知识，不知道该从哪里开始入手，便从<code>Java</code>的关键字开始，由此扩展出相关知识。</p><h2 id="java中的关键字" tabindex="-1"><a class="header-anchor" href="#java中的关键字"><span>Java中的关键字</span></a></h2><div class="hint-container tip"><p class="hint-container-title">关键字</p><p>包引入和包声明: <code>import</code>, <code>package</code><br> 类和接口的声明: <code>class</code>, <code>extends</code>, <code>implements</code>, <code>interface</code><br> 数据类型: <code>byte</code>, <code>boolean</code>, <code>char</code>, <code>double</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>short</code><br> 某些数据类型的可选值: <code>flase</code>, <code>ture</code>, <code>null</code><br> 流程控制: <code>break</code>, <code>case</code>, <code>continue</code>, <code>default</code>, <code>do</code>, <code>else</code>, <code>for</code>, <code>if</code>, <code>return</code>, <code>switch</code>, <code>while</code><br> 异常处理: <code>catch</code>, <code>finally</code>, <code>throw</code>, <code>throws</code>, <code>try</code><br> 修饰符: <code>abstract</code>, <code>final</code>, <code>native</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>, <code>synchronilzed</code>, <code>transient</code>, <code>volatitle</code><br> 操作符: <code>instanceof</code><br> 创建对象: <code>new</code><br> 引用: <code>this</code>, <code>supper</code><br> 方法返回类型: <code>void</code><br> 保留字: <code>const</code>, <code>goto</code></p></div><hr><h2 id="标识符" tabindex="-1"><a class="header-anchor" href="#标识符"><span>标识符</span></a></h2><p>自定义标识符可以由大小写字母、数字、下划线(<code>_</code>)、美元符号(<code>$</code>)组成，但不能以数字开头，不能是Java中的保留字或关键字。</p><hr><h2 id="static关键字" tabindex="-1"><a class="header-anchor" href="#static关键字"><span>static关键字</span></a></h2><ol><li>静态变量: 类被加在时创建，访问静态变量不需要产生类的实例对象，不能把方法体内的变量声明为静态。</li><li>静态方法: 可以用类名或实例对象访问，也可以在类的非静态方法中访问。</li><li>静态代码块: 类第一次被加载时执行，且只被执行一次，其常用来进行类属性的初始化。</li></ol><p><strong>注:</strong></p><ol><li>静态方法内不能以任何方式引用<code>this</code>和<code>super</code>关键字。</li><li>静态方法内只能直接调用静态成员(变量和方法)，而不能直接访问类中的非静态成员。</li></ol><hr><h2 id="final关键字" tabindex="-1"><a class="header-anchor" href="#final关键字"><span>final关键字</span></a></h2><p><code>final</code>关键字可以修饰类、方法和属性</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span>修饰类   : 该类不能被继承</span></span>
<span class="line"><span>修饰方法 : 该方法不能被覆盖(重写)</span></span>
<span class="line"><span>修饰属性 : 该属性为常量,只能赋值一次,必须在声明时或在构造方法中显示赋值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注:</strong></p><ol><li>方法中定义的内部类只能访问该方法内的final型局部变量</li><li>在Java中通常使用<code>public static final</code>的组合方式标识常量，这样的常量就成为了全局的常量，且只能在定义时赋值</li></ol><hr><h2 id="继承相关" tabindex="-1"><a class="header-anchor" href="#继承相关"><span>继承相关</span></a></h2><ol><li>只能单继承，不能多继承，但可以多层继承(<code>extends、class</code>)</li><li>可以实现多个接口(<code>implements、interface</code>)</li><li>子类继承父类所有的成员变量和成员方法，但不继承父类的构造方法。</li><li>若不写构造方法，java会自动生成一个无参的构造方法，若写了任何构造方法，则不再默认生成； 子类若不通过<code>super</code>显式地调用父类构造方法，则默认调用父类无参构造方法，若父类没有无参构造方法，则会出错。</li><li>子类覆盖父类的方法时，不能使用比父类中被覆盖方法更严格的访问权限。</li></ol><hr><h2 id="访问权限" tabindex="-1"><a class="header-anchor" href="#访问权限"><span>访问权限</span></a></h2><p>访问控制修饰符共有四个: <code>public、protected、(default)、private</code>, <code>default</code>即为不写时的修饰。</p><p>修饰成员:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span>public    : 可以被所有类访问</span></span>
<span class="line"><span>protected : 既可以被同一包中的其他类访问, 也可以被不同包中的子类访问</span></span>
<span class="line"><span>default   : 只能被同一包中的其他类访问</span></span>
<span class="line"><span>private   : 只能在这个类的内部访问</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修饰类(只有两种访问控制：<code>public</code>和<code>default</code>):</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span>public    : 能被所有的类访问, public修饰的类必须与文件名一致</span></span>
<span class="line"><span>default   : 只能被同一包中所有的类访问</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="抽象类和接口" tabindex="-1"><a class="header-anchor" href="#抽象类和接口"><span>抽象类和接口</span></a></h2><h3 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类"><span>抽象类</span></a></h3><ol><li>抽象方法的写法为<code>&quot;abstract 返回值类型 抽象方法名 (参数列表);&quot;</code>，只声明不实现</li><li>只要有一个抽象方法，该类就是抽象类，必须用<code>abstract class</code>声明</li><li>抽象类不能实例化，其子类必须覆盖所有的抽象方法后才能被实例化，否则其子类也还是抽象类</li><li><code>abstract</code>不能与<code>private、static、final、native</code>并列修饰同一个方法</li></ol><h3 id="接口" tabindex="-1"><a class="header-anchor" href="#接口"><span>接口</span></a></h3><ol><li>接口用<code>interface</code>声明，是一种特殊的抽象类，只包含<strong>常量</strong>和方法的定义，而没方法的实现</li><li>接口中定义的变量是<strong>全局静态常量</strong>，默认(不写)是用<code>public static final</code>标记的</li><li>一个类可以在继承一个父类的同时实现一个或多个接口，此时<code>extends</code>关键字必须位于<code>implements</code>关键字之前</li><li>接口中的方法默认都是<code>public abstract</code>类型的，即使不饰符，也是这种类型的。</li></ol><hr><h2 id="instanceof操作符" tabindex="-1"><a class="header-anchor" href="#instanceof操作符"><span>instanceof操作符</span></a></h2><p>可以使用<code>instanceof</code>操作符判断一个类是否实现了某个接口，或用来判断一个实例对象是否属于某个类。其语法格式为：对象 instanceof 类（或接口）</p><hr><h2 id="native关键字" tabindex="-1"><a class="header-anchor" href="#native关键字"><span>native关键字</span></a></h2><p>在<code>JKD</code>源码中总会看到<code>native</code>的方法，如:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">	// Object中</span></span>
<span class="line"><span style="color:#F97583;">	public</span><span style="color:#F97583;"> native</span><span style="color:#F97583;"> int</span><span style="color:#B392F0;"> hashCode</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">	protected</span><span style="color:#F97583;"> native</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">clone</span><span style="color:#E1E4E8;">() throws CloneNotSupportedException;</span></span>
<span class="line"><span style="color:#6A737D;">	// String中</span></span>
<span class="line"><span style="color:#F97583;">	public</span><span style="color:#F97583;"> native</span><span style="color:#E1E4E8;"> String </span><span style="color:#B392F0;">intern</span><span style="color:#E1E4E8;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>native</code>关键字表明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。<br> Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI(Java Native Interface，本机编程接口，是SDK的一部分)调用其他语言来实现对底层的访问。<br> 怎么写JNI这里就不说了。</p><hr><h2 id="transient关键字" tabindex="-1"><a class="header-anchor" href="#transient关键字"><span>transient关键字</span></a></h2><p><code>Java</code>的序列化机制可以把实现了<code>Serializable</code>接口的对象进行持久存储，而被<code>transient</code>关键字修饰的字段，在序列化时就会被忽略。</p><hr><h2 id="volatitle关键字" tabindex="-1"><a class="header-anchor" href="#volatitle关键字"><span>volatitle关键字</span></a></h2><p><code>volatitle</code>关键字用于多线程的环境中，用<code>volatitle</code>修饰的变量，每次取值时都会取修改后的值，即该变量不会装入寄存器，每次改变都写入内存，每次读取都到内存中去取。<br> 两个线程同时对<code>int a = 0;</code>定义好的<code>a</code>进行<code>a++</code>操作时，线程1对a自增之后未写回，线程2又对a进行了自增，就会导致与预期结果不一样。</p><hr><h2 id="synchronilzed关键字" tabindex="-1"><a class="header-anchor" href="#synchronilzed关键字"><span>synchronilzed关键字</span></a></h2><p><code>synchronized</code>关键字用于实现多线程的同步，在多线程访问的时候，所有加上<code>synchronized</code>的方法或块语句，同一时刻只能有一个线程能够用访问。</p><p>正好写个线程安全的单例模式(懒汉)来体现下<code>volatitle</code>和<code>synchronilzed</code>的作用</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">publicclass Singleton {</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> volatile</span><span style="color:#E1E4E8;"> Singleton instance </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#B392F0;"> Singleton</span><span style="color:#E1E4E8;">() { }</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#E1E4E8;"> Singleton </span><span style="color:#B392F0;">getInstance</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (instance </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {  </span><span style="color:#6A737D;">// 注意这里有两次判断，里面那个判断是必须有的，外面这个判断可提高效率</span></span>
<span class="line"><span style="color:#F97583;">            synchronized</span><span style="color:#E1E4E8;"> (Singleton.class) {</span></span>
<span class="line"><span style="color:#F97583;">                if</span><span style="color:#E1E4E8;"> (instance </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    instance </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Singleton</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>`,53),c=[o];function i(t,d){return n(),a("div",null,c)}const h=e(l,[["render",i],["__file","2015-02-16-java基础整理.html.vue"]]),v=JSON.parse('{"path":"/program/backend/2015-02-16-java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86.html","title":"Java基础整理","lang":"zh-CN","frontmatter":{"title":"Java基础整理","date":"2015-02-16T00:00:00.000Z","category":"Java","tag":"Java","order":-20150216,"description":"回顾Java的基础知识，不知道该从哪里开始入手，便从Java的关键字开始，由此扩展出相关知识。 Java中的关键字 关键字 包引入和包声明: import, package 类和接口的声明: class, extends, implements, interface 数据类型: byte, boolean, char, double, int, lon...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/backend/2015-02-16-java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"Java基础整理"}],["meta",{"property":"og:description","content":"回顾Java的基础知识，不知道该从哪里开始入手，便从Java的关键字开始，由此扩展出相关知识。 Java中的关键字 关键字 包引入和包声明: import, package 类和接口的声明: class, extends, implements, interface 数据类型: byte, boolean, char, double, int, lon..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T14:41:23.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2015-02-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-23T14:41:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java基础整理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2015-02-16T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-23T14:41:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"Java中的关键字","slug":"java中的关键字","link":"#java中的关键字","children":[]},{"level":2,"title":"标识符","slug":"标识符","link":"#标识符","children":[]},{"level":2,"title":"static关键字","slug":"static关键字","link":"#static关键字","children":[]},{"level":2,"title":"final关键字","slug":"final关键字","link":"#final关键字","children":[]},{"level":2,"title":"继承相关","slug":"继承相关","link":"#继承相关","children":[]},{"level":2,"title":"访问权限","slug":"访问权限","link":"#访问权限","children":[]},{"level":2,"title":"抽象类和接口","slug":"抽象类和接口","link":"#抽象类和接口","children":[{"level":3,"title":"抽象类","slug":"抽象类","link":"#抽象类","children":[]},{"level":3,"title":"接口","slug":"接口","link":"#接口","children":[]}]},{"level":2,"title":"instanceof操作符","slug":"instanceof操作符","link":"#instanceof操作符","children":[]},{"level":2,"title":"native关键字","slug":"native关键字","link":"#native关键字","children":[]},{"level":2,"title":"transient关键字","slug":"transient关键字","link":"#transient关键字","children":[]},{"level":2,"title":"volatitle关键字","slug":"volatitle关键字","link":"#volatitle关键字","children":[]},{"level":2,"title":"synchronilzed关键字","slug":"synchronilzed关键字","link":"#synchronilzed关键字","children":[]}],"git":{"createdTime":1719153683000,"updatedTime":1719153683000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/backend/2015-02-16-java基础整理.md","localizedDate":"2015年2月16日","excerpt":"","autoDesc":true}');export{h as comp,v as data};
