import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as e,d as a}from"./app-Biz7QJq3.js";const n={},o=a(`<p>java反射中经常用到Class类, 本文对它以及它的方法进行简单说明</p><h2 id="class类简介" tabindex="-1"><a class="header-anchor" href="#class类简介"><span>Class类简介</span></a></h2><p>Class类位于<code>java.lang</code>包中, Class类的实例表示正在运行的Java应用程序中的类和接口.<br> 枚举算类, 注解算接口; 数组算类,它映射的Class对象被有着相同元素和大小的数组共享;<br> Java的原生(primitive types)类型(<code>boolean、byte、char、short、int、long、float、double</code>)和关键字<code>void</code>也代表Class对象.</p><p>Class类实现了<code>Serializable、GenericDeclaration、Type、AnnotatedElement</code>接口</p><p>Class类无public构造函数, Class类对象是由JVM在类加载的时候调用类加载器的<code>defineClass</code>方法创建的.<br> 如下方法能够获取类名:</p><ul><li><code>obj.getClass().getName()</code></li><li><code>Foo.class.getName()</code></li></ul><h2 id="判定方法" tabindex="-1"><a class="header-anchor" href="#判定方法"><span>判定方法</span></a></h2><p>这些方法可以判断某个类是否是接口、是否是枚举、是否是注解、是否有某个注解、是否是匿名类、是否是某个类的超类(是否可强制转换为该类)等</p><ol><li><code>boolean isArray()</code>: 是否是数组; <code>int[].class.isArray()</code>为<code>true</code></li><li><code>boolean isAnnotation()</code>: 是否是注解, 若返回<code>true</code>,则<code>isInterface</code>也为<code>ture</code>; <code>Target.class.isAnnotation()</code>为<code>true</code></li><li><code>boolean isEnum()</code>: 是否是枚举类</li><li><code>boolean isPrimitive()</code>: 是否是原生类型(共9个, 包装类返回<code>false</code>), <code>void.class.isArray()</code>为<code>true</code></li><li><code>boolean isInterface()</code>: 是否是接口</li><li><code>boolean isMemberClass()</code>: 是否是成员类, 类的定义在另一个类里面的那种</li><li><code>boolean isAnonymousClass()</code>: 是否是匿名类</li><li><code>boolean isLocalClass()</code>: 是否是本地类</li><li><code>boolean isSynthetic()</code>: 是否是复合类 (接口<code>Member</code>也有这个方法)</li><li><code>boolean isInstance(Object obj)</code>: obj是否是该类的一个实例</li><li><code>boolean isAssignableFrom(Class&lt;?&gt; cls)</code>: cls是否可以被转换成该类</li><li><code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>: 该类上是否存在这个注解(继承自接口<code>AnnotatedElement</code>)</li></ol><p>下面是几个方法的实例说明:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    class</span><span style="color:#B392F0;"> Test</span><span style="color:#E1E4E8;">{}  </span><span style="color:#6A737D;">// 这是传说中的成员类</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        class</span><span style="color:#B392F0;"> LocalClass</span><span style="color:#E1E4E8;">{}  </span><span style="color:#6A737D;">// 这是传说中的本地类</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object obj </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Hello</span><span style="color:#E1E4E8;">(){    </span><span style="color:#6A737D;">// Hello是其他地方定义的一个接口, 有一个sayHello()方法, 这就是匿名类(无类名)</span></span>
<span class="line"><span style="color:#F97583;">            public</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> sayHello</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        };</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Test.class.</span><span style="color:#B392F0;">isMemberClass</span><span style="color:#E1E4E8;">());         </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(obj.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">isAnonymousClass</span><span style="color:#E1E4E8;">());  </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(LocalClass.class.</span><span style="color:#B392F0;">isLocalClass</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Hello.class.</span><span style="color:#B392F0;">isInstance</span><span style="color:#E1E4E8;">(obj));        </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(Bean.class.</span><span style="color:#B392F0;">isAnnotationPresent</span><span style="color:#E1E4E8;">(Target.class));        </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>instanceof</code>、 <code>isInstance</code>、 <code>isAssignableFrom</code>的区别</li></ul><p><code>instanceof</code>运算符只被用于对象引用变量, 比如: <code>自身类或子类的实例 instanceof 自身类</code> 返回true<br><code>isInstance(Object obj)</code>是<code>instanceof</code>运算符的动态等价, 比如: <code>自身类.class.isInstance(自身类或子类的实例)</code> 返回true<br><code>isAssignableFrom(Class&lt;?&gt; cls)</code>是两个类之间的关系, 比如: <code>自身类.class.isAssignableFrom(自身类或子类.class)</code> 返回true</p><h2 id="获取内容系列方法" tabindex="-1"><a class="header-anchor" href="#获取内容系列方法"><span>获取内容系列方法</span></a></h2><p>通过Class类可以获取这个类的一些内容性质的信息, 比如属性、方法、构造方法、注解</p><h3 id="获取属性" tabindex="-1"><a class="header-anchor" href="#获取属性"><span>获取属性</span></a></h3><ol><li><code>Field[] getFields()</code>: 获取本类或父类中所有public属性</li><li><code>Field getField(String name)</code>: 获取本类或父类中特定名字的public属性</li><li><code>Field[] getDeclaredFields()</code>: 获取本类中声明的所有属性</li><li><code>Field getDeclaredField(String name)</code>: 获取本类中声明的特定名字的属性</li></ol><h3 id="获取方法" tabindex="-1"><a class="header-anchor" href="#获取方法"><span>获取方法</span></a></h3><ol><li><code>Method[] getMethods()</code>: 获取本类或父类中所有public方法(包括构造器方法)</li><li><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>: 获取本类或父类中特定名字和参数的public方法</li><li><code>Method[] getDeclaredMethods()</code>: 获取本类中声明的所有方法(包括非public但不包括继承来的)</li><li><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>: 获取本类中声明的特定名字和参数的方法(最常用)</li></ol><h3 id="获取构造方法" tabindex="-1"><a class="header-anchor" href="#获取构造方法"><span>获取构造方法</span></a></h3><ol><li><code>Constructor&lt;?&gt;[] getConstructors()</code>: 获取本类中所有public构造器</li><li><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>: 获取本类中特定参数的public构造器</li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code>: 获取本类中所有构造器</li><li><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>: 获取本类中指定参数的构造器</li></ol><h3 id="获取注解" tabindex="-1"><a class="header-anchor" href="#获取注解"><span>获取注解</span></a></h3><p>这几个方法均继承自接口<code>AnnotatedElement</code></p><ol><li><code>Annotation[] getAnnotations()</code>: 获取这个元素上的所有注解(包括父类上被<code>@Inherited</code>标记的注解)</li><li><code>&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)</code>: 获取这个元素上指定类型的注解, 没有返回null</li><li><code>Annotation[] getDeclaredAnnotations()</code>: 获取直接标注在这个元素上的注解</li></ol><h3 id="父类子类-接口-相关" tabindex="-1"><a class="header-anchor" href="#父类子类-接口-相关"><span>父类子类(接口)相关</span></a></h3><ol><li><code>Class&lt;? super T&gt; getSuperclass()</code>: 返回本类的父类(直接超类);<code>int[].class</code>为<code>Object</code>, <code>int.class</code>为<code>null</code>, <code>Object.class</code>为<code>null</code></li><li><code>Type getGenericSuperclass()</code>: 以Type的形式返回本类的父类, 带有范型信息(没有范型信息时把Class以Type形式返回)</li><li><code>Class&lt;?&gt;[] getInterfaces()</code>: 返回本类<strong>直接实现</strong>的接口</li><li><code>Type[] getGenericInterfaces()</code>: 以Type的形式返回本类<strong>直接实现</strong>的接口, 带有范型信息</li><li><code>&lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) </code>: 把当前类转为clazz表示的子类(或自己), 不能转抛<code>ClassCastException</code>异常</li></ol><p><code>asSubclass</code>的作用</p><p><code>ArrayList.class.asSubclass(List.class)</code>得到的还是<code>ArrayList.class</code>, 看起来没什么作用<br> 但是它的作用体现在<strong>窄化未知的Class类型的范围</strong>, 比如通常我们用到<code>Class.forName(&quot;XXX&quot;)</code>, 它的返回是<code>Class&lt;?&gt;</code>比较宽泛, 我们可以窄化一下: <code>Class.forName(&quot;XXX&quot;).asSubclass(List.class).newInstance()</code>. 当<code>XXX</code>不是<code>List</code>的子类时,抛出<code>ClassCastException</code>异常</p><h3 id="内部类相关" tabindex="-1"><a class="header-anchor" href="#内部类相关"><span>内部类相关</span></a></h3><ol><li><code>Class&lt;?&gt; getEnclosingClass()</code>: 获取底层类的直接封闭类, 如上面<code>LocalClass</code>的封闭类为<code>Main</code>, 那个匿名类的封闭类也是<code>Main</code></li><li><code>Constructor&lt;?&gt; getEnclosingConstructor()</code>: 若该Class对象是在一个构造方法中的本地类或匿名类时, 返回这个构造器对象, 表示底层类直接封闭构造方法, 否则返回<code>null</code>; 上面的<code>LocalClass</code>不在构造方法中,因此返回<code>null</code></li><li><code>Method getEnclosingMethod()</code>: 若该Class对象是在一个方法中的本地类或匿名类时, 返回这个<code>Method</code>对象, 表示底层类的直接封闭方法, 否则返回<code>null</code></li><li><code>Class&lt;?&gt; getDeclaringClass()</code>: 该类是另一个类的成员(<code>isMemberClass</code>),则返回该类的声明类(外部类); 接口<code>Member</code>中也有该方法</li><li><code>Class&lt;?&gt;[] getDeclaredClasses() </code>: 返回该类中直接声明的所有类</li><li><code>Class&lt;?&gt;[] getClasses() </code>: 返回该类中直接声明的所有public类</li></ol><h2 id="名字相关" tabindex="-1"><a class="header-anchor" href="#名字相关"><span>名字相关</span></a></h2><ol><li><code>static Class&lt;?&gt; forName(String className)</code>: 返回与给定的字符串名称相关联的Class对象</li><li><code>String getSimpleName()</code>: 返回源码中定义的简单类名, 匿名类返回空串, 数组返回&quot;组件类型[]&quot;</li><li><code>String getCanonicalName</code>: 返回底层类的Java语言规范中定义的标准名称</li><li><code>public String getName()</code>: 返回此Class对象所表示的实体(类，接口，数组类，基本类型或void)的名字, 略复杂,规则如下:</li></ol><ul><li>若是原始类型(class), 则返回Java语言规范中定义的标准名称</li><li>若是原生类型(primitive)或void, 直接返回关键字对应的字符串</li><li>若是数组, 则用&quot;[&quot;代表数组维度,后面跟上元素类型代码,具体如下表:</li></ul><table><thead><tr><th style="text-align:left;">元素类型</th><th style="text-align:left;">类型代码</th></tr></thead><tbody><tr><td style="text-align:left;">boolean</td><td style="text-align:left;">Z</td></tr><tr><td style="text-align:left;">byte</td><td style="text-align:left;">B</td></tr><tr><td style="text-align:left;">char</td><td style="text-align:left;">C</td></tr><tr><td style="text-align:left;">double</td><td style="text-align:left;">D</td></tr><tr><td style="text-align:left;">float</td><td style="text-align:left;">F</td></tr><tr><td style="text-align:left;">int</td><td style="text-align:left;">I</td></tr><tr><td style="text-align:left;">long</td><td style="text-align:left;">J</td></tr><tr><td style="text-align:left;">short</td><td style="text-align:left;">S</td></tr><tr><td style="text-align:left;">class or interface</td><td style="text-align:left;">Lclassname;</td></tr></tbody></table><p>来个例子:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> ClassTest</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Class clazz </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> String.class;</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getSimpleName</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">// String</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getCanonicalName</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// java.lang.String</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());          </span><span style="color:#6A737D;">// java.lang.String</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        clazz </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> int.class;</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getSimpleName</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">// int</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getCanonicalName</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// int</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());          </span><span style="color:#6A737D;">// int</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">        String</span><span style="color:#E1E4E8;">[] strings </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#E1E4E8;">        clazz </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> strings.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getSimpleName</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">// String[]</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getCanonicalName</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// java.lang.String[]</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());          </span><span style="color:#6A737D;">// [Ljava.lang.String;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">        int</span><span style="color:#E1E4E8;">[][] array </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span><span style="color:#F97583;">new</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;">[]{</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">}, </span><span style="color:#F97583;">new</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;">[]{</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">}};</span></span>
<span class="line"><span style="color:#E1E4E8;">        clazz </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> array.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getSimpleName</span><span style="color:#E1E4E8;">());    </span><span style="color:#6A737D;">// int[][]</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getCanonicalName</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// int[][]</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(clazz.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());          </span><span style="color:#6A737D;">// [[I</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="其他方法" tabindex="-1"><a class="header-anchor" href="#其他方法"><span>其他方法</span></a></h3><ol><li><code>TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters()</code>: 继承自接口<code>GenericDeclaration</code>,按照声明顺序返回声明的类型变量</li><li><code>Class&lt;?&gt; getComponentType()</code>: 若该类是个数组，则返回组件的类型</li></ol><p>还有一些方法暂不介绍了.</p>`,39),t=[o];function c(p,i){return l(),e("div",null,t)}const E=s(n,[["render",c],["__file","2016-02-25-Class类简介.html.vue"]]),y=JSON.parse('{"path":"/program/code/2016-02-25-Class%E7%B1%BB%E7%AE%80%E4%BB%8B.html","title":"Class类简介","lang":"zh-CN","frontmatter":{"title":"Class类简介","date":"2016-02-25T00:00:00.000Z","category":"Java","tag":["反射"],"order":-20160225,"description":"java反射中经常用到Class类, 本文对它以及它的方法进行简单说明 Class类简介 Class类位于java.lang包中, Class类的实例表示正在运行的Java应用程序中的类和接口. 枚举算类, 注解算接口; 数组算类,它映射的Class对象被有着相同元素和大小的数组共享; Java的原生(primitive types)类型(boolea...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/code/2016-02-25-Class%E7%B1%BB%E7%AE%80%E4%BB%8B.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"Class类简介"}],["meta",{"property":"og:description","content":"java反射中经常用到Class类, 本文对它以及它的方法进行简单说明 Class类简介 Class类位于java.lang包中, Class类的实例表示正在运行的Java应用程序中的类和接口. 枚举算类, 注解算接口; 数组算类,它映射的Class对象被有着相同元素和大小的数组共享; Java的原生(primitive types)类型(boolea..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-16T03:30:34.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"反射"}],["meta",{"property":"article:published_time","content":"2016-02-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-16T03:30:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Class类简介\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-02-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-16T03:30:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"Class类简介","slug":"class类简介","link":"#class类简介","children":[]},{"level":2,"title":"判定方法","slug":"判定方法","link":"#判定方法","children":[]},{"level":2,"title":"获取内容系列方法","slug":"获取内容系列方法","link":"#获取内容系列方法","children":[{"level":3,"title":"获取属性","slug":"获取属性","link":"#获取属性","children":[]},{"level":3,"title":"获取方法","slug":"获取方法","link":"#获取方法","children":[]},{"level":3,"title":"获取构造方法","slug":"获取构造方法","link":"#获取构造方法","children":[]},{"level":3,"title":"获取注解","slug":"获取注解","link":"#获取注解","children":[]},{"level":3,"title":"父类子类(接口)相关","slug":"父类子类-接口-相关","link":"#父类子类-接口-相关","children":[]},{"level":3,"title":"内部类相关","slug":"内部类相关","link":"#内部类相关","children":[]}]},{"level":2,"title":"名字相关","slug":"名字相关","link":"#名字相关","children":[{"level":3,"title":"其他方法","slug":"其他方法","link":"#其他方法","children":[]}]}],"git":{"createdTime":1719158757000,"updatedTime":1723779034000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/code/2016-02-25-Class类简介.md","localizedDate":"2016年2月25日","excerpt":"","autoDesc":true}');export{E as comp,y as data};
