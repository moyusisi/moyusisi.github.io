import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as a,d as l}from"./app-J8acWEVP.js";const e={},p=l(`<p>C语言需要开发者进行内存管理，所以开发者对内存的分配比较清楚，可以通过<code>sizeof()</code>函数获取一个变量的大小；<br> java通过JVM进行内存管理，它的内存占用情况是怎样的？</p><h2 id="原始类型的大小" tabindex="-1"><a class="header-anchor" href="#原始类型的大小"><span>原始类型的大小</span></a></h2><p>在java中，不管32位还是64位，原始类型的内存占用大小是确定的，如下:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> 原始类型 </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> 大小 </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#F97583;">  boolean</span><span style="color:#F97583;"> |</span><span style="color:#79B8FF;">   1</span><span style="color:#F97583;">   |</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#F97583;">  byte</span><span style="color:#F97583;">    |</span><span style="color:#79B8FF;">   1</span><span style="color:#F97583;">   |</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#F97583;">  short</span><span style="color:#F97583;">   |</span><span style="color:#79B8FF;">   2</span><span style="color:#F97583;">   |</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#F97583;">  char</span><span style="color:#F97583;">    |</span><span style="color:#79B8FF;">   2</span><span style="color:#F97583;">   |</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#F97583;">  int</span><span style="color:#F97583;">     |</span><span style="color:#79B8FF;">   4</span><span style="color:#F97583;">   |</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#F97583;">  float</span><span style="color:#F97583;">   |</span><span style="color:#79B8FF;">   4</span><span style="color:#F97583;">   |</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#F97583;">  long</span><span style="color:#F97583;">    |</span><span style="color:#79B8FF;">   8</span><span style="color:#F97583;">   |</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#F97583;">  double</span><span style="color:#F97583;">  |</span><span style="color:#79B8FF;">   8</span><span style="color:#F97583;">   |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="引用的大小" tabindex="-1"><a class="header-anchor" href="#引用的大小"><span>引用的大小</span></a></h2><p>java中没有指针，只有引用，引用是安全的，这个说法不错，但实际上引用也就是指针,<br> 所以32位的地址对应的指针大小为4B(4<code>*</code>8bits)，64位的地址对应的指针大小为8B(8<code>*</code>8bits)。<br> 但是，从JDK6以后JVM都默认开启了<strong>指针压缩</strong>(JVM运行参数为<code>-XX:+UseCompressedOops</code>)。<br> 开启指针压缩后引用就成了4字节，所以:</p><ul><li>32位JVM，引用为4B</li><li>64位JVM开启<code>UseCompressedOops</code>，引用为4B</li><li>64位JVM未开启<code>UseCompressedOops</code>，引用为8B</li></ul><p>可通过<code>jinfo -flag UseCompressedOops &lt;pid&gt;</code>查看是否开启了指针压缩</p><h2 id="关于对齐" tabindex="-1"><a class="header-anchor" href="#关于对齐"><span>关于对齐</span></a></h2><p>CPU从内存中读取数据是以word为基本单位, 32位的系统中word宽度为32bits, 64位的系统中word宽度为64bits, 将整个Java对象占用内存补长为word的整倍数大大提高了CPU存取数据的性能。<br> 但是在Hotspot虚拟机中，不管是32位系统还是64位系统，都是8字节对齐。</p><h1 id="对象头部的大小" tabindex="-1"><a class="header-anchor" href="#对象头部的大小"><span>对象头部的大小</span></a></h1><p>对象头的结构如下(<a href="http://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2008-May/000147.html" target="_blank" rel="noopener noreferrer">来源</a>):</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span>+------------------+------------------+------------------ +---------------+</span></span>
<span class="line"><span>|    mark word     |   klass pointer  |  array size (opt) |    padding    |</span></span>
<span class="line"><span>+------------------+------------------+-------------------+---------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mark-word" tabindex="-1"><a class="header-anchor" href="#mark-word"><span>mark word</span></a></h3><p>用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄(Generational GCAge)等。<br> 在32位机中占4B，在64位机中占8B。<br> 它是非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><h3 id="klass-pointer" tabindex="-1"><a class="header-anchor" href="#klass-pointer"><span>klass pointer</span></a></h3><p>用于存储指向方法区对象类型数据的指针。<br> 在32位JVM上为4B，在未开启<code>UseCompressedOops</code>的64位JVM上为8B，在开启<code>UseCompressedOops</code>的64位机上为4B。</p><h3 id="array-size" tabindex="-1"><a class="header-anchor" href="#array-size"><span>array size</span></a></h3><p>如果该对象是数组对象的话，还会有一个额外的部分用于存储数组长度</p><h3 id="padding" tabindex="-1"><a class="header-anchor" href="#padding"><span>padding</span></a></h3><p>8字节对齐的填充(这个部分可被称为gap，开启压缩的时候，这个gap会尽量用一个int或者float填充)</p><h2 id="java对象的内存分配" tabindex="-1"><a class="header-anchor" href="#java对象的内存分配"><span>java对象的内存分配</span></a></h2><p>一个对象在内存中存储的布局可以分为三块区域：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)。<br> 按照64位JVM默认的开启<code>UseCompressedOops</code>的情况说明普通对象、数组对象、字符串对象的内存分配</p><h3 id="普通对象" tabindex="-1"><a class="header-anchor" href="#普通对象"><span>普通对象</span></a></h3><p>普通对象的对象头中，无array size，有或者无padding，紧跟着就是对象的成员变量<br> 网上找了个例子来说明:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> Demo</span><span style="color:#E1E4E8;"> {  </span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> long</span><span style="color:#E1E4E8;"> L </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0x7EFFFFFFFFL</span><span style="color:#E1E4E8;">;  </span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> I </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0x7FFFFF</span><span style="color:#E1E4E8;">;  </span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> J </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0x7EFFFF</span><span style="color:#E1E4E8;">;  </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// Demo的地址分配</span></span>
<span class="line"><span style="color:#79B8FF;">0x00000007d569f1c8</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x0000000000000001</span></span>
<span class="line"><span style="color:#79B8FF;">0x00000007d569f1d0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x007fffffef650cc4</span></span>
<span class="line"><span style="color:#79B8FF;">0x00000007d569f1d8</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x0000007effffffff</span></span>
<span class="line"><span style="color:#79B8FF;">0x00000007d569f1e0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x00000000007effff</span></span>
<span class="line"><span style="color:#6A737D;">// 对于Demo地址分配的解释(x86是小端模式:数据的低位保存在内存的低地址中)</span></span>
<span class="line"><span style="color:#E1E4E8;">_mark</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">             0x00000007d569f1c8</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x0000000000000001</span></span>
<span class="line"><span style="color:#E1E4E8;">_compressed_klass</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x00000007d569f1d0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0xef650cc4</span></span>
<span class="line"><span style="color:#E1E4E8;">I</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">                 0x00000007d569f1d4</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x007fffff</span><span style="color:#6A737D;">        // gap填充</span></span>
<span class="line"><span style="color:#E1E4E8;">L</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">                 0x00000007d569f1d8</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x0000007effffffff</span></span>
<span class="line"><span style="color:#E1E4E8;">J</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">                 0x00000007d569f1e0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x007effff</span></span>
<span class="line"><span style="color:#E1E4E8;">(padding)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">         0x00000007d569f1e4</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> 0x00000000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明:</p><ol><li>JDK7默认开了<a href="http://rednaxelafx.iteye.com/blog/1010079" target="_blank" rel="noopener noreferrer">压缩指针</a></li><li>无论开不开<code>UseCompressedOops</code>， 64位<code>HotSpot VM</code>的<code>mark word</code>都是8字节。</li><li>如果开启<code>UseCompressedOops</code>的话，<code>_compressed_klass</code>占4字节；反之则<code>_klass</code>占8字节。</li><li><code>_compressed_klass</code>要转换回到正常oop需要做一定运算，具体是什么运算取决于当前的压缩模式</li><li>这个对象头只需要8+4=12B，而long/double必须在8B对齐的地址上分配，所以中间有4字节的空隙(gap)。</li><li>这个gap可以尽可能的填充1个int/float，或者2个short/char，或者4个byte/boolean。</li></ol><h3 id="数组对象" tabindex="-1"><a class="header-anchor" href="#数组对象"><span>数组对象</span></a></h3><p>数组对象的对象头中，array size将占用4B，紧跟着就是数组对象的数组元素</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> o[] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {}  </span><span style="color:#6A737D;">// 16(header) = 8(_mark) + 4(_compressed_klass) + 4(size)</span></span>
<span class="line"><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">};    </span><span style="color:#6A737D;">// 24 = 16 + 1*5 + 3(padding)</span></span>
<span class="line"><span style="color:#E1E4E8;">object[] o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> object</span><span style="color:#E1E4E8;">()};   </span><span style="color:#6A737D;">// 24 = 16 + 4*1 + 4(padding)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="字符串对象" tabindex="-1"><a class="header-anchor" href="#字符串对象"><span>字符串对象</span></a></h3><p>把字符串对象当成一个普通的对象来看，它有3个实例成员(可能不同版本jdk，String的成员不太一样，但是算法是一样的):</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#F97583;"> final</span><span style="color:#F97583;"> char</span><span style="color:#E1E4E8;"> value[];        </span><span style="color:#6A737D;">// 一个数组的引用，4B</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> hash;                  </span><span style="color:#6A737D;">// int 4B</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#F97583;"> transient</span><span style="color:#F97583;"> int</span><span style="color:#E1E4E8;"> hash32 </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// int 4B</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此一个String对象的大小为:<code>24 = 8(_mark) + 4(_compressed_klass) + 4 + 4 + 4</code>(gap部分被填充)<br><code>String s = &quot;abc&quot; </code>是String的成员变量value数组指向<code>&quot;abc&quot;</code></p><hr><h2 id="对象大小的计算" tabindex="-1"><a class="header-anchor" href="#对象大小的计算"><span>对象大小的计算</span></a></h2><p>原始类型的大小是固定的，不需要计算；对象的大小可用<code>java.lang.instrument.Instrumentation</code>计算(后面再说)； 但是<code>Instrumentation#getObjectSize</code>方法返回的大小不包括对象的成员变量所引用的对象。<br> 我们可以遍历对象的成员变量进行递归计算，在计算时需要考虑到：</p><ol><li>对象的static成员不需要计算(类成员在静态区)</li><li>如果两个成员变量引用的是同一个对象，则这个对象不能重复计算，即算过的不能再算</li><li>原生类型的成员变量不需要计算，如Person类有个成员变量<code>int age</code>, 计算Person的实例大小的时候已经算上int的大小了， 变量age不能再计算了，也没办法再计算，因为age不是引用。</li><li>享元模式的成员变量不需要计算，如<code>Integer#valueOf()</code>值在<code>-128~127</code>之间的都是享元，<code>Enum</code>对象都是享元。</li><li><code>intern string</code>不需要计算,<code>intern string</code>在java8之前存在于字符串常量池，位于永生代(非堆)</li><li>数组对象需要遍历每个对象进行计算</li><li>对于普通对象，如果该对象有父类，则需要计算继承自父类的成员变量</li></ol><p>也就是说计算对象大小的时候可以分为三类: 直接跳过计算的对象(1、2、3、4、5)、数组对象(6)、普通对象(7)<br> 我们用<code>Stack&lt;Object&gt; stack</code>来存放待计算对象(初始只有一个元素), 用<code>IdentityHashMap</code>记录<code>visited</code>的对象<br> 这里给出代码片段:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 判断该对象是否需要跳过计算</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> boolean</span><span style="color:#B392F0;"> skipObject</span><span style="color:#E1E4E8;">(Object obj, Map</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Object, Object</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> visited) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#79B8FF;"> null</span><span style="color:#F97583;"> ==</span><span style="color:#E1E4E8;"> obj </span><span style="color:#F97583;">||</span><span style="color:#6A737D;">               // null 直接跳过</span></span>
<span class="line"><span style="color:#B392F0;">                isSharedFlyweight</span><span style="color:#E1E4E8;">(obj) </span><span style="color:#F97583;">||</span><span style="color:#6A737D;">   // 享元对象 跳过</span></span>
<span class="line"><span style="color:#E1E4E8;">                visited.</span><span style="color:#B392F0;">containsKey</span><span style="color:#E1E4E8;">(obj);   </span><span style="color:#6A737D;">// 计算过的对象 跳过</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 计算栈顶元素大小</span></span>
<span class="line"><span style="color:#6A737D;">     *</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#FFAB70;"> stack</span><span style="color:#6A737D;">   待计算对象栈</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#FFAB70;"> visited</span><span style="color:#6A737D;"> 已经计算过的对象</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> long</span><span style="color:#B392F0;"> doSizeOf</span><span style="color:#E1E4E8;">(Stack</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Object</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> stack, Map</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Object, Object</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> visited) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 获取栈顶元素</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object obj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">        // 如果该对象需要跳过计算，直接返回0</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">skipObject</span><span style="color:#E1E4E8;">(obj, visited)) {</span></span>
<span class="line"><span style="color:#F97583;">            return</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#6A737D;">        // 先把该对象放到已经访问过的集合中</span></span>
<span class="line"><span style="color:#E1E4E8;">        visited.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(obj, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">        // 计算这个对象的大小 (object header + primitive variables + member pointers)</span></span>
<span class="line"><span style="color:#F97583;">        long</span><span style="color:#E1E4E8;"> result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> SizeOf.</span><span style="color:#B392F0;">sizeOf</span><span style="color:#E1E4E8;">(obj);</span></span>
<span class="line"><span style="color:#6A737D;">        // 获取对象类型</span></span>
<span class="line"><span style="color:#E1E4E8;">        Class clazz </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> obj.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">        // 如果该对象是数组类型，则还需要把数组元素压栈待计算, 然后返回</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (clazz.</span><span style="color:#B392F0;">isArray</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#6A737D;">            // 如果该数组的元素的类型是原生类型，就不用压栈了(即使压栈，也因是skipObject而被忽略)</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">clazz.</span><span style="color:#B392F0;">getComponentType</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">isPrimitive</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#F97583;">                int</span><span style="color:#E1E4E8;"> length </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Array.</span><span style="color:#B392F0;">getLength</span><span style="color:#E1E4E8;">(obj);</span></span>
<span class="line"><span style="color:#F97583;">                for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    stack.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(Array.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(obj, i));  </span><span style="color:#6A737D;">// 数组元素压栈</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 即不是skipObject，也不是数组，那只能是普通对象了，则对该对象的成员变量进行处理</span></span>
<span class="line"><span style="color:#F97583;">            while</span><span style="color:#E1E4E8;"> (clazz </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">                Field</span><span style="color:#E1E4E8;">[] fields </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> clazz.</span><span style="color:#B392F0;">getDeclaredFields</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 获取所有成员</span></span>
<span class="line"><span style="color:#F97583;">                for</span><span style="color:#E1E4E8;"> (Field field </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> fields) {</span></span>
<span class="line"><span style="color:#6A737D;">                    // 只将非static成员和非primitive成员压栈</span></span>
<span class="line"><span style="color:#F97583;">                    if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">Modifier.</span><span style="color:#B392F0;">isStatic</span><span style="color:#E1E4E8;">(field.</span><span style="color:#B392F0;">getModifiers</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#F97583;"> !</span><span style="color:#E1E4E8;">field.</span><span style="color:#B392F0;">getType</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">isPrimitive</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        field.</span><span style="color:#B392F0;">setAccessible</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">                        try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                            stack.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(field.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(obj));</span></span>
<span class="line"><span style="color:#E1E4E8;">                        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (IllegalAccessException </span><span style="color:#FFAB70;">ex</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">                            throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> RuntimeException</span><span style="color:#E1E4E8;">(ex);</span></span>
<span class="line"><span style="color:#E1E4E8;">                        }</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                clazz </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> clazz.</span><span style="color:#B392F0;">getSuperclass</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 继续处理父类的成员</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="编程计算对象的大小" tabindex="-1"><a class="header-anchor" href="#编程计算对象的大小"><span>编程计算对象的大小</span></a></h2><p>JDK7的<code>java.lang.instrument</code>包中有个<code>Instrumentation API</code>提供了<code>getObjectSize</code>方法来计算对象的大小, 这个方法返回的是对象的大小，不包括其成员变量所引用的对象(<code>sun.instrumentInstrumentationImpl</code>实现了该接口)。 而且，这个方法不能直接使用，必须实现一个<code>instrumentation</code>代理类并且打包进JAR文件。</p><h3 id="定义代理类" tabindex="-1"><a class="header-anchor" href="#定义代理类"><span>定义代理类</span></a></h3><p>我们这样定义代理类:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#F97583;"> class</span><span style="color:#B392F0;"> SizeOf</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * JVM将在启动时通过{@link #premain}初始化此成员变量.</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#F97583;">    private</span><span style="color:#F97583;"> static</span><span style="color:#E1E4E8;"> Instrumentation instrumentation;</span></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * JVM会调用该函数来初始化代理类</span></span>
<span class="line"><span style="color:#6A737D;">     *</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#FFAB70;"> agentArgs</span><span style="color:#6A737D;"> premain 函数得到的程序参数，随同 “–javaagent:”一起传入。</span></span>
<span class="line"><span style="color:#6A737D;">     *                  eg:java -javaagent:jar 文件的位置 [= 传入 premain 的参数 ]</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#FFAB70;"> inst</span><span style="color:#6A737D;">      java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> void</span><span style="color:#B392F0;"> premain</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">agentArgs</span><span style="color:#E1E4E8;">, Instrumentation </span><span style="color:#FFAB70;">inst</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        instrumentation </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> inst;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 返回对象大小，不包括其成员变量所引用的对象</span></span>
<span class="line"><span style="color:#6A737D;">     *</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#FFAB70;"> object</span><span style="color:#6A737D;"> 需要计算大小的对象</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@return</span><span style="color:#6A737D;"> 对象的大小</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@see</span><span style="color:#6A737D;"> java.lang.instrument.Instrumentation#getObjectSize(Object objectToSize)</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> long</span><span style="color:#B392F0;"> sizeOf</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">object</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (instrumentation </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">            throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> IllegalStateException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Instrumentation is null&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> instrumentation.</span><span style="color:#B392F0;">getObjectSize</span><span style="color:#E1E4E8;">(object);  </span><span style="color:#6A737D;">// 通过Instrumentation的实现类计算</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    /**</span></span>
<span class="line"><span style="color:#6A737D;">     * 返回包含引用对象在内的大小(需要我们自己计算)</span></span>
<span class="line"><span style="color:#6A737D;">     *</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@param</span><span style="color:#FFAB70;"> obj</span><span style="color:#6A737D;"> 需要计算大小的对象</span></span>
<span class="line"><span style="color:#6A737D;">     * </span><span style="color:#F97583;">@return</span><span style="color:#6A737D;"> 对象的全部大小</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#F97583;">    public</span><span style="color:#F97583;"> static</span><span style="color:#F97583;"> long</span><span style="color:#B392F0;"> fullSizeOf</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">) { ... }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="将代理类打成jar包" tabindex="-1"><a class="header-anchor" href="#将代理类打成jar包"><span>将代理类打成jar包</span></a></h3><p>为了让JVM知道instrumentation代理类的存在，必须将其打包进JAR文件并且设定manifest.mf文件中的属性。 在我们的例子中，需要设定如下属性：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" data-title="properties" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">Premain-Class: 代理类SizeOf的全类名  </span></span>
<span class="line"><span style="color:#E1E4E8;">Can-Redefine-Classes: true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以通过maven工具进行打包，打包的时候可以指定生成<code>manifest.mf</code>的属性， 在<code>pom.xml</code>文件中可以在<code>&lt;build&gt;</code>元素中添加<code>&lt;plugins&gt;</code>元素，添加maven打包插件，就像这样:</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">build</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;</span><span style="color:#85E89D;">plugins</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">            &lt;!-- maven 打包插件, 可指定生成的 META-INF/manifest.mf 文件中的属性 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">            &lt;</span><span style="color:#85E89D;">plugin</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt;org.apache.maven.plugins&lt;/</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt;maven-jar-plugin&lt;/</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;</span><span style="color:#85E89D;">version</span><span style="color:#E1E4E8;">&gt;2.1&lt;/</span><span style="color:#85E89D;">version</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;</span><span style="color:#85E89D;">configuration</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    &lt;</span><span style="color:#85E89D;">archive</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">                        &lt;!-- 生成 manifest.mf 时添加的属性 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                        &lt;</span><span style="color:#85E89D;">manifestEntries</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                            &lt;</span><span style="color:#85E89D;">Premain-Class</span><span style="color:#E1E4E8;">&gt;cn.loveshisong.sizeof.SizeOf&lt;/</span><span style="color:#85E89D;">Premain-Class</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                            &lt;</span><span style="color:#85E89D;">Can-Redefine-Classes</span><span style="color:#E1E4E8;">&gt;true&lt;/</span><span style="color:#85E89D;">Can-Redefine-Classes</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                        &lt;/</span><span style="color:#85E89D;">manifestEntries</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    &lt;/</span><span style="color:#85E89D;">archive</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;/</span><span style="color:#85E89D;">configuration</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">            &lt;/</span><span style="color:#85E89D;">plugin</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;/</span><span style="color:#85E89D;">plugins</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#85E89D;">build</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="配置虚拟机参数-使用代理" tabindex="-1"><a class="header-anchor" href="#配置虚拟机参数-使用代理"><span>配置虚拟机参数，使用代理</span></a></h3><p>另外，Java程序必须使用 -javaagent 参数指向该jar文件来启动。我们的例子中形如：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#B392F0;">java</span><span style="color:#79B8FF;"> -javaagent:代理类jar包的位置</span><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#B392F0;">java</span><span style="color:#79B8FF;"> -javaagent:sizeofag.jar</span><span style="color:#E1E4E8;"> (jar包在classpath中可以这么写)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以在进行测试的时候，通过maven的插件来指定JVM运行参数:</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="background-color:#24292e;color:#e1e4e8;"><pre class="shiki github-dark vp-code"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">build</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">plugins</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">        &lt;!-- 上面那个plugin不要忘了加上 --&gt;</span></span>
<span class="line"><span style="color:#6A737D;">        &lt;!-- 测试运行器(Test Runner), 执行到特定生命周期阶段的时候，通过该插件来执行JUnit或者TestNG的测试用例 --&gt;</span></span>
<span class="line"><span style="color:#6A737D;">        &lt;!-- maven-surefire-plugin 在test时默认执行 src/test/java/ 下所有名为*Test.java和*TestCase.java的测试类 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;</span><span style="color:#85E89D;">plugin</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">            &lt;</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt;org.apache.maven.plugins&lt;/</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">            &lt;</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt;maven-surefire-plugin&lt;/</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">            &lt;</span><span style="color:#85E89D;">configuration</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;</span><span style="color:#85E89D;">forkMode</span><span style="color:#E1E4E8;">&gt;pertest&lt;/</span><span style="color:#85E89D;">forkMode</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">                &lt;!-- argLine指定了VM运行参数 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;</span><span style="color:#85E89D;">argLine</span><span style="color:#E1E4E8;">&gt;-javaagent:\${basedir}/target/sizeof-\${project.version}.jar&lt;/</span><span style="color:#85E89D;">argLine</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;</span><span style="color:#85E89D;">workingDirectory</span><span style="color:#E1E4E8;">&gt;\${basedir}/target&lt;/</span><span style="color:#85E89D;">workingDirectory</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                &lt;</span><span style="color:#85E89D;">useSystemClassLoader</span><span style="color:#E1E4E8;">&gt;true&lt;/</span><span style="color:#85E89D;">useSystemClassLoader</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">            &lt;/</span><span style="color:#85E89D;">configuration</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;/</span><span style="color:#85E89D;">plugin</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#85E89D;">plugins</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">build</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们在使用<code>junit</code>进行单元测试的时候，就已经给JVM传递了参数。</p><h2 id="在程序中使用例子中的jar包" tabindex="-1"><a class="header-anchor" href="#在程序中使用例子中的jar包"><span>在程序中使用例子中的jar包</span></a></h2><p>只有一点，在其它项目中使用这个打包好的jar包时，记得给JVM传递代理类参数。<br> 另外，不同机器可能junit的测试会有问题，最好把源码下载下来，自己打包，必要时删掉测试代码。</p>`,59),o=[p];function r(t,i){return n(),a("div",null,o)}const E=s(e,[["render",r],["__file","2015-06-11-java对象的内存大小.html.vue"]]),y=JSON.parse('{"path":"/program/java/2015-06-11-java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F.html","title":"java对象的内存大小","lang":"zh-CN","frontmatter":{"title":"java对象的内存大小","date":"2015-06-11T00:00:00.000Z","category":"Java","tag":["JVM"],"order":-20150611,"description":"C语言需要开发者进行内存管理，所以开发者对内存的分配比较清楚，可以通过sizeof()函数获取一个变量的大小； java通过JVM进行内存管理，它的内存占用情况是怎样的？ 原始类型的大小 在java中，不管32位还是64位，原始类型的内存占用大小是确定的，如下: 引用的大小 java中没有指针，只有引用，引用是安全的，这个说法不错，但实际上引用也就是指...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/program/java/2015-06-11-java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F.html"}],["meta",{"property":"og:site_name","content":"魔芋丝丝"}],["meta",{"property":"og:title","content":"java对象的内存大小"}],["meta",{"property":"og:description","content":"C语言需要开发者进行内存管理，所以开发者对内存的分配比较清楚，可以通过sizeof()函数获取一个变量的大小； java通过JVM进行内存管理，它的内存占用情况是怎样的？ 原始类型的大小 在java中，不管32位还是64位，原始类型的内存占用大小是确定的，如下: 引用的大小 java中没有指针，只有引用，引用是安全的，这个说法不错，但实际上引用也就是指..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-09T09:40:25.000Z"}],["meta",{"property":"article:author","content":"moyusisi"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2015-06-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-09T09:40:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java对象的内存大小\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2015-06-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-09T09:40:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"moyusisi\\"}]}"]]},"headers":[{"level":2,"title":"原始类型的大小","slug":"原始类型的大小","link":"#原始类型的大小","children":[]},{"level":2,"title":"引用的大小","slug":"引用的大小","link":"#引用的大小","children":[]},{"level":2,"title":"关于对齐","slug":"关于对齐","link":"#关于对齐","children":[{"level":3,"title":"mark word","slug":"mark-word","link":"#mark-word","children":[]},{"level":3,"title":"klass pointer","slug":"klass-pointer","link":"#klass-pointer","children":[]},{"level":3,"title":"array size","slug":"array-size","link":"#array-size","children":[]},{"level":3,"title":"padding","slug":"padding","link":"#padding","children":[]}]},{"level":2,"title":"java对象的内存分配","slug":"java对象的内存分配","link":"#java对象的内存分配","children":[{"level":3,"title":"普通对象","slug":"普通对象","link":"#普通对象","children":[]},{"level":3,"title":"数组对象","slug":"数组对象","link":"#数组对象","children":[]},{"level":3,"title":"字符串对象","slug":"字符串对象","link":"#字符串对象","children":[]}]},{"level":2,"title":"对象大小的计算","slug":"对象大小的计算","link":"#对象大小的计算","children":[]},{"level":2,"title":"编程计算对象的大小","slug":"编程计算对象的大小","link":"#编程计算对象的大小","children":[{"level":3,"title":"定义代理类","slug":"定义代理类","link":"#定义代理类","children":[]},{"level":3,"title":"将代理类打成jar包","slug":"将代理类打成jar包","link":"#将代理类打成jar包","children":[]},{"level":3,"title":"配置虚拟机参数，使用代理","slug":"配置虚拟机参数-使用代理","link":"#配置虚拟机参数-使用代理","children":[]}]},{"level":2,"title":"在程序中使用例子中的jar包","slug":"在程序中使用例子中的jar包","link":"#在程序中使用例子中的jar包","children":[]}],"git":{"createdTime":1719153683000,"updatedTime":1725874825000,"contributors":[{"name":"moyusisi","email":"moyusisi@126.com","commits":1}]},"filePathRelative":"program/java/2015-06-11-java对象的内存大小.md","localizedDate":"2015年6月11日","excerpt":"","autoDesc":true}');export{E as comp,y as data};
